# Instead of using artifacts, just build in an NFS-mounted directory,
# $BUILD_DIR, that's unique to each pipeline in case there are concurrent
# pipelines.  Why not use artifacts?
#
# - [The following numbers are a bit old, and they were recorded for a debug
#   build.]
# - LLVM's build directory is huge.  For me, it's 46G when including just
#   the clang and openmp subprojects, which are required for Clacc, and it's
#   85G when including nearly all subprojects.
# - At this size, it takes a long time to upload/download between stages and
#   can be rejected as an upload because of its size.  For me, it added 20
#   min to the already 30 min build of that 46G and then was rejected.
# - Artifacts are posted for download and stored long past when it's useful
#   for humans to download the LLVM build directory, which is typically
#   never.
# - We could squash the pipeline to one stage to avoid the need for
#   artifacts, but pipeline stages are a convenient way to view results when
#   debugging.
#
# The NFS solution used here is based on the following comment (which is in
# response to a proposal for a gitlab feature that would solve this
# problem):
#
#   https://gitlab.com/gitlab-org/gitlab/issues/29265#note_225288132
#
# However, because the NFS-mounted build directory name is different for each
# pipeline, ccache misses if we compile within it.  Thus, we set
# CCACHE_NOHASHDIR and CCACHE_BASEDIR (neither alone proves sufficient), as
# suggested by the ccache manual.  CCACHE_NOHASHDIR can lead to incorrect
# directory names in debugging symbols, but currently we don't expect those to
# matter to our CI builds.
variables:
  BUILD_DIR_PROJ: $CI_BUILDS_DIR/$CI_PROJECT_PATH_SLUG-builds
  BUILD_DIR: $CI_BUILDS_DIR/$CI_PROJECT_PATH_SLUG-builds/$CI_PIPELINE_ID-$BUILD_ID
  BUILD_DIRS: $CI_BUILDS_DIR/$CI_PROJECT_PATH_SLUG-builds/$CI_PIPELINE_ID-*
  LLVM_CCACHE_PARAMS: 'CCACHE_CPP2=yes CCACHE_NOHASHDIR=yes CCACHE_BASEDIR=$CI_BUILDS_DIR/$CI_PROJECT_PATH_SLUG-builds'
  LLVM_TARGETS_TO_BUILD: all
  LIT_NPROC_DIVISOR: 1

stages:
  - setup
  - config
  - build
  - test
  - cleanup
  - manual cleanup

#-------------------------------------------------
# build configurations
#
# Test every architecture with a release build plus assertions using python3.
# There are many kolds, so use them to check configuration choices that are
# hopefully orthogonal to the architecture.
#-------------------------------------------------

.leconte:
  tags: [shell, leconte]
  variables:
    BUILD_ID: leconte
    MODULES: cmake/3.19.2 gnu/9.2.0 nvhpc/21.2
    PATH_PREPEND:
      /opt/nvidia/hpc_sdk/Linux_ppc64le/21.2/cuda/11.0/bin
    CMAKE: cmake
    NINJA: ninja
    PYTHON: /usr/bin/python3
    CMAKE_BUILD_OPTS: -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_ASSERTIONS=True
    LLVM_ENABLE_PROJECTS: "clang"
    LLVM_ENABLE_RUNTIMES: "openmp"
    CPU_TRIPLE: "powerpc64le-ibm-linux-gnu"
    CPU_COUNT:  4
    GPU_TRIPLE: "nvptx64-nvidia-cuda"
    GPU_COUNT:  6
    LIT_NPROC_DIVISOR: 4
    LIT_XFAIL:
      "
      libomp :: affinity/kmp-hw-subset.c
      libomp :: atomic/kmp_atomic_float10_max_min.c
      libomp :: env/kmp_set_dispatch_buf.c
      libomptarget :: nvptx64-nvidia-cuda :: offloading/bug49334.cpp
      libomptarget :: nvptx64-nvidia-cuda-newRTL :: offloading/bug49334.cpp
      libomptarget :: powerpc64le-ibm-linux-gnu :: offloading/memory_manager.cpp
      libomptarget :: powerpc64le-ibm-linux-gnu :: offloading/parallel_offloading_map.cpp
      libomptarget :: powerpc64le-ibm-linux-gnu :: offloading/taskloop_offload_nowait.cpp
      "
    LIT_XFAIL_NOT:
      "
      libomptarget :: nvptx64-nvidia-cuda :: unified_shared_memory/api.c
      libomptarget :: nvptx64-nvidia-cuda-newRTL :: unified_shared_memory/api.c
      "

.oswald02:
  tags: [shell, oswald02]
  variables:
    BUILD_ID: oswald02
    MODULES: cmake gnu/11.1.0 nvhpc/21.7
    PATH_PREPEND:
      /opt/nvidia/hpc_sdk/Linux_x86_64/21.7/cuda/11.4/bin
    CMAKE: cmake
    NINJA: ninja
    PYTHON: /usr/bin/python3
    CMAKE_BUILD_OPTS: -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_ASSERTIONS=True
    LLVM_ENABLE_PROJECTS: "clang"
    LLVM_ENABLE_RUNTIMES: "openmp"
    CPU_TRIPLE: "x86_64-pc-linux-gnu"
    CPU_COUNT:  4
    GPU_TRIPLE: "nvptx64-nvidia-cuda"
    GPU_COUNT:  1
    LIT_NPROC_DIVISOR: 1
    LIT_XFAIL:
      "
      libomptarget :: nvptx64-nvidia-cuda :: offloading/bug49334.cpp
      libomptarget :: nvptx64-nvidia-cuda-newRTL :: offloading/bug49334.cpp
      "
    LIT_XFAIL_NOT:
      ""

.explorer:
  tags: [shell, explorer]
  variables:
    BUILD_ID: explorer
    MODULES: ""
    PATH_PREPEND: ""
    CMAKE: cmake
    GCC_DIR: /usr
    NINJA: ninja
    PYTHON: /usr/bin/python3
    CMAKE_BUILD_OPTS: -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_ASSERTIONS=True
    # If lld isn't built, OpenMP offloading tests for AMDGPU fail:
    #
    #   clang-14: error: unable to execute command: Executable "lld" doesn't exist!
#   #   clang-14: error: amdgcn-link command failed with exit code 1 (use -v to see invocation)
    LLVM_ENABLE_PROJECTS: "clang;lld"
    LLVM_ENABLE_RUNTIMES: "openmp"
    CPU_TRIPLE: "x86_64-pc-linux-gnu"
    CPU_COUNT:  4
    GPU_TRIPLE: "amdgcn-amd-amdhsa"
    GPU_COUNT:  2
    LIT_NPROC_DIVISOR: 1
    LIT_XFAIL: ""
    LIT_XFAIL_NOT: ""

.kold:
  tags: [shell, kold]
  variables:
    BUILD_ID: kold
    MODULES: gnu/11.1.0
    PATH_PREPEND: ""
    CMAKE: cmake3
    NINJA: ninja-build
    PYTHON: /usr/bin/python3
    CMAKE_BUILD_OPTS: -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_ASSERTIONS=True
    # FIXME: Many of Clacc's Clang OpenACC tests fail if we let
    # LLVM_TARGETS_TO_BUILD default to "all":
    #
    #   clang-14: error: cannot find libdevice for sm_35; provide path to different CUDA installation via '--cuda-path', or pass '-nocudalib' to build without linking with libdevice
    #
    # The trouble is that Clang's OpenACC test suite relies solely on
    # llvm_omp_device_info to determine available devices, and it reports an
    # NVIDIA GPU even though the kolds don't have required libraries for Clang
    # to compile for it.  Thus, we set LLVM_TARGETS_TO_BUILD to disable support
    # for targets beyond host.  In the future, all end-to-end compilation
    # testing of Clang's OpenACC support should move into the libacc2omp test
    # suite, which reuses libomptarget's detection of supported devices, which
    # correctly suppresses NVIDIA GPU support in this case.
    LLVM_TARGETS_TO_BUILD: "host"
    LLVM_ENABLE_PROJECTS: "clang"
    LLVM_ENABLE_RUNTIMES: "openmp"
    CPU_TRIPLE: "x86_64-pc-linux-gnu"
    CPU_COUNT:  4
    LIT_XFAIL: ""
    LIT_XFAIL_NOT: ""

.no-asserts:
  extends: [.kold]
  variables:
    BUILD_ID: no-asserts
    CMAKE_BUILD_OPTS: -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_ASSERTIONS=False
    LIT_XFAIL:
      "
      Clang :: Headers/wasm.c
      LLVM :: Analysis/CostModel/X86/interleaved-store-accesses-with-gaps.ll
      "
    LIT_XFAIL_NOT:
      ""

.debug:
  extends: [.kold]
  variables:
    BUILD_ID: debug
    CMAKE_BUILD_OPTS: -DCMAKE_BUILD_TYPE=Debug
    LIT_XFAIL:
      "
      libomptarget :: x86_64-pc-linux-gnu :: offloading/bug49334.cpp
      libomptarget :: x86_64-pc-linux-gnu :: offloading/memory_manager.cpp
      libomptarget :: x86_64-pc-linux-gnu :: offloading/parallel_offloading_map.cpp
      "
    LIT_XFAIL_NOT:
      ""

# Not setup or cleanup.
.non-utility:
  dependencies: []
  variables:
    GIT_STRATEGY: none
  before_script:
    - echo $MODULES
    - if test x"$MODULES" != x; then module load $MODULES; fi
    - echo $PATH_PREPEND
    - if test x"$PATH_PREPEND" != x; then PATH="$PATH_PREPEND:$PATH"; fi
    - echo $PATH
    - pwd
    - echo $BUILD_DIR
    - cd $BUILD_DIR/build
    # Sometimes a build process gets stuck for a long time, and sometimes a test
    # process does (usually OpenMP tests).  One hour of CPU time should be
    # plenty for any process.  The goal is simply not to let them stick around
    # forever.
    - ulimit -t 3600
  after_script:
    - echo "$LLVM_CCACHE_PARAMS"
    - env $LLVM_CCACHE_PARAMS ccache -sp
    - du -hs $BUILD_DIR/build

#-------------------------------------------------
# setup
#-------------------------------------------------

.setup:
  stage: setup
  script:
    - pwd
    - echo $BUILD_DIR_PROJ
    # Try to remove anything older than 6 hours that was left by a previous
    # pipeline for this project.  Doing this in the setup stage instead of
    # cleanup stage ensures that it runs before a new job even if prior jobs
    # failed or were canceled.  git clone creates files with old modification
    # times, so check file creation time (-cmin) instead.
    - find $BUILD_DIR_PROJ -cmin +360 -delete || true
    - mkdir -p $BUILD_DIR_PROJ
    - echo $BUILD_DIR
    # Remove this build config's build directory if it already exists.  It
    # might exist if, for example, this setup job previously failed due to a
    # transient Gitlab/ExCL problem.
    - rm -rf $BUILD_DIR
    - mkdir $BUILD_DIR
    - mkdir $BUILD_DIR/build
    # Clone the runner's git clone into the NFS-mounted build directory.  We
    # cannot use the runner's git clone directly because its location relative
    # to the build directory varies across runners, and that would cause ccache
    # to miss whenever the runner changes no matter how we set CCACHE_BASEDIR.
    # We've also tried creating a symlink to the runner's git clone at the
    # start of every job, but that causes ccache to miss in the same manner, so
    # apparently the symlink is expanded somewhere.
    - git --version
    - time git clone `pwd` $BUILD_DIR/source

leconte (setup):
  extends: [.leconte, .setup]

oswald02 (setup):
  extends: [.oswald02, .setup]

explorer (setup):
  extends: [.explorer, .setup]

kold (setup):
  extends: [.kold, .setup]

no-asserts (setup):
  extends: [.no-asserts, .setup]

debug (setup):
  extends: [.debug, .setup]

#-------------------------------------------------
# cleanup
#-------------------------------------------------

.rm-build-dir:
  variables:
    GIT_STRATEGY: none
  script:
    - pwd
    - echo $BUILD_DIR
    - rm -rf $BUILD_DIR
    - rmdir $BUILD_DIR_PROJ || true

.cleanup:
  stage: cleanup
  extends: .rm-build-dir

.manual-cleanup:
  stage: manual cleanup
  extends: .rm-build-dir
  when: manual
  needs: []

leconte (cleanup):
  extends: [.leconte, .cleanup]
  needs:
    - job: leconte (test)
      artifacts: false

oswald02 (cleanup):
  extends: [.oswald02, .cleanup]
  needs:
    - job: oswald02 (test)
      artifacts: false

explorer (cleanup):
  extends: [.explorer, .cleanup]
  needs:
    - job: explorer (test)
      artifacts: false

kold (cleanup):
  extends: [.kold, .cleanup]
  needs:
    - job: kold (test)
      artifacts: false

no-asserts (cleanup):
  extends: [.no-asserts, .cleanup]
  needs:
    - job: no-asserts (test)
      artifacts: false

debug (cleanup):
  extends: [.debug, .cleanup]
  needs:
    - job: debug (test)
      artifacts: false

leconte (manual cleanup):
  extends: [.leconte, .manual-cleanup]

oswald02 (manual cleanup):
  extends: [.oswald02, .manual-cleanup]

explorer (manual cleanup):
  extends: [.explorer, .manual-cleanup]

kold (manual cleanup):
  extends: [.kold, .manual-cleanup]

no-asserts (manual cleanup):
  extends: [.no-asserts, .manual-cleanup]

debug (manual cleanup):
  extends: [.debug, .manual-cleanup]

z-cleanup-pipeline-builds:
  stage: manual cleanup
  when: manual
  needs: []
  tags: [shell, kold]
  variables:
    GIT_STRATEGY: none
  script:
    - echo $BUILD_DIRS
    - rm -rf $BUILD_DIRS

z-cleanup-project-builds:
  stage: manual cleanup
  when: manual
  needs: []
  tags: [shell, kold]
  variables:
    GIT_STRATEGY: none
  script:
    - echo $BUILD_DIR_PROJ
    - rm -rf $BUILD_DIR_PROJ

#-------------------------------------------------
# config
#-------------------------------------------------

.config:
  extends: .non-utility
  stage: config
  script:
    - echo $CMAKE
    - $CMAKE --version
    - echo $CMAKE_BUILD_OPTS
    - echo $GCC_DIR
    - echo $LLVM_CCACHE_PARAMS
    - echo $PYTHON
    - $PYTHON --version
    - echo $LLVM_TARGETS_TO_BUILD
    - echo $LLVM_ENABLE_PROJECTS
    - echo $LLVM_ENABLE_RUNTIMES
    - time $CMAKE -G Ninja
                  $CMAKE_BUILD_OPTS
                  -DLLVM_CCACHE_BUILD=ON
                  -DLLVM_USE_SPLIT_DWARF=true
                  -DLLVM_USE_LINKER=gold
                  -DCMAKE_C_COMPILER=gcc
                  -DCMAKE_CXX_COMPILER=g++
                  -DGCC_INSTALL_PREFIX=$GCC_DIR
                  -DLLVM_CCACHE_PARAMS="$LLVM_CCACHE_PARAMS"
                  -DLLVM_TARGETS_TO_BUILD="$LLVM_TARGETS_TO_BUILD"
                  -DLLVM_ENABLE_PROJECTS="$LLVM_ENABLE_PROJECTS"
                  -DLLVM_ENABLE_RUNTIMES="$LLVM_ENABLE_RUNTIMES"
                  -DPython3_EXECUTABLE=$PYTHON
                  -DLLVM_LIT_ARGS='-s -vv'
                  ../source/llvm
      |& tee $CI_PROJECT_DIR/cmake-log.txt
    - cp CMakeCache.txt $CI_PROJECT_DIR
  artifacts:
    when: always
    paths: [cmake-log.txt, CMakeCache.txt]

leconte (config):
  extends: [.leconte, .config]
  needs:
    - job: leconte (setup)
      artifacts: false

oswald02 (config):
  extends: [.oswald02, .config]
  needs:
    - job: oswald02 (setup)
      artifacts: false

explorer (config):
  extends: [.explorer, .config]
  needs:
    - job: explorer (setup)
      artifacts: false

kold (config):
  extends: [.kold, .config]
  needs:
    - job: kold (setup)
      artifacts: false

no-asserts (config):
  extends: [.no-asserts, .config]
  needs:
    - job: no-asserts (setup)
      artifacts: false

debug (config):
  extends: [.debug, .config]
  needs:
    - job: debug (setup)
      artifacts: false

#-------------------------------------------------
# build
#-------------------------------------------------

.build:
  extends: .non-utility
  stage: build
  script:
    - echo $NINJA
    - $NINJA --version
    - time $NINJA -l `nproc` |& tee $CI_PROJECT_DIR/build-log.txt
  artifacts:
    when: always
    paths: [build-log.txt]

leconte (build):
  extends: [.leconte, .build]
  needs:
    - job: leconte (config)
      artifacts: false

oswald02 (build):
  extends: [.oswald02, .build]
  needs:
    - job: oswald02 (config)
      artifacts: false

explorer (build):
  extends: [.explorer, .build]
  needs:
    - job: explorer (config)
      artifacts: false

kold (build):
  extends: [.kold, .build]
  needs:
    - job: kold (config)
      artifacts: false

no-asserts (build):
  extends: [.no-asserts, .build]
  needs:
    - job: no-asserts (config)
      artifacts: false

debug (build):
  extends: [.debug, .build]
  needs:
    - job: debug (config)
      artifacts: false

#-------------------------------------------------
# tests
#-------------------------------------------------

.test:
  extends: .non-utility
  stage: test
  script:
    - echo $CHECK_TARGETS
    - echo $NINJA
    - $NINJA --version
    - export LIT_XFAIL=`
        echo "$LIT_XFAIL"
        | sed -e 's/\([^:]\)  *\([^:]\)/\1;\2/g' -e 's/^ *//' -e 's/ *$//'
      `
    - export LIT_XFAIL_NOT=`
        echo "$LIT_XFAIL_NOT"
        | sed -e 's/\([^:]\)  *\([^:]\)/\1;\2/g' -e 's/^ *//' -e 's/ *$//'
      `
    - echo "$LIT_XFAIL"
    - echo "$LIT_XFAIL_NOT"
    # Build test suite before running it so we can time those steps separately.
    - time LIT_FILTER_OUT=. LIT_OPTS=--allow-empty-runs
      $NINJA -l `nproc` check-all
      |& tee $CI_PROJECT_DIR/check-all-build-log.txt
    # Check that no misconfiguration is quietly disabling key features and thus
    # tests.  For example, not adding the gitlab-runner account to the required
    # render/video groups quietly disables OpenMP offloading to AMD GPU.
    #
    # Check that device counts are computed correctly by the test suite based on
    # known device counts for each host.
    #
    # A grep failure within an "if" terminates the "if" as expected, but somehow
    # it doesn't cause the job to fail or prevent commands in subsequent list
    # items from executing unless we have the "|| false" after the "fi".  This
    # doesn't make sense to me, but it's how gitlab CI apparently works right
    # now.
    - tl=$CI_PROJECT_DIR/check-all-show-tests.txt
    - LIT_OPTS=--show-tests $NINJA check-all > $tl 2>&1
    - echo "$CPU_TRIPLE" "$CPU_COUNT" &&
      echo "$GPU_TRIPLE" "$GPU_COUNT"
    - echo "Test counts for libomptarget "'::'" $CPU_TRIPLE (expecting > 0):" &&
      grep -c "^ *libomptarget "'::'" $CPU_TRIPLE ::" $tl
    - if test x"$GPU_TRIPLE" != x; then
         echo "Test counts for libomptarget "'::'" $GPU_TRIPLE (expecting > 0):"
         && grep -c "^ *libomptarget "'::'" $GPU_TRIPLE ::" $tl;
      fi || false
    - clacc_branch=`
        echo "$CI_COMMIT_BRANCH" |
        grep '^\(clacc\|jdenny-openacc\)' |
        grep -v '^clacc/llvm.org-ci/' ||
        true`
    - echo "$clacc_branch"
    - if test x"$clacc_branch" != x; then
        echo "Test counts for libacc2omp "'::'" $CPU_TRIPLE (expecting > 0):" &&
        grep -c "^ *libacc2omp "'::'" $CPU_TRIPLE ::" $tl &&
        prefix="Device counts for" &&
        echo "Device counts for $CPU_TRIPLE (expecting $CPU_COUNT):" &&
        for suite in "libacc2omp "'::'" $CPU_TRIPLE"
                     "libacc2omp "'::'" multitarget"
                     "Clang"; do
          grep "$prefix '$suite'.*'$CPU_TRIPLE'"':'" $CPU_COUNT[,}]" $tl;
        done &&
        if test x"$GPU_TRIPLE" != x; then
          echo "Test counts for libacc2omp "'::'" $GPU_TRIPLE (expecting > 0):"
          && grep -c "^ *libacc2omp "'::'" $GPU_TRIPLE ::" $tl &&
          echo "Device counts for $GPU_TRIPLE (expecting $GPU_COUNT):" &&
          for suite in "libacc2omp "'::'" $GPU_TRIPLE"
                       "libacc2omp "'::'" multitarget"
                       "Clang"; do
            grep "$prefix '$suite'.*'$GPU_TRIPLE'"':'" $GPU_COUNT[,}]" $tl;
          done
        fi
      fi || false
    # Run the test suite.
    #
    # LIT_NPROC_DIVISOR is set to limit the number of tests launched at once so
    # we don't overwhelm the accelerators (leconte GPUs, in particular),
    # producing OpenMP offload test failures.
    #
    # ulimit -t does not terminate processes that are hung and not using CPUs,
    # but hopefully lit's --timeout will.  40 mins ought to be long enough for
    # any regression test.
    #
    # In case check-all runs multiple lit invocations (e.g., a separate
    # invocation for openmp because it's in LLVM_ENABLE_RUNTIMES), use lit's
    # --ignore-fail so that all lit invocations actually run.  The count printed
    # by grep tells us how many test suite summaries we need to search for.
    - NPROC=`nproc`
    - echo "$NPROC"
    - echo "$LIT_NPROC_DIVISOR"
    - time FILECHECK_OPTS='-dump-input-filter=all -vv -color'
      LIT_OPTS="
        --timeout 2400 -j `expr $NPROC / $LIT_NPROC_DIVISOR`
        --ignore-fail --xunit-xml-output $CI_PROJECT_DIR/check-all.xml
      "
      $NINJA -l `nproc` check-all
      |& tee $CI_PROJECT_DIR/check-all-log.txt
    - "! grep -c \"'--ignore-fail' was specified\"
                 $CI_PROJECT_DIR/check-all-log.txt"
  artifacts:
    when: always
    paths: [check-all-build-log.txt, check-all-show-tests.txt,
            check-all-log.txt, check-all.xml]
    reports:
      junit: check-all.xml

leconte (test):
  extends: [.leconte, .test]
  needs:
    - job: leconte (build)
      artifacts: false

oswald02 (test):
  extends: [.oswald02, .test]
  needs:
    - job: oswald02 (build)
      artifacts: false

explorer (test):
  extends: [.explorer, .test]
  needs:
    - job: explorer (build)
      artifacts: false

kold (test):
  extends: [.kold, .test]
  needs:
    - job: kold (build)
      artifacts: false

no-asserts (test):
  extends: [.no-asserts, .test]
  needs:
    - job: no-asserts (build)
      artifacts: false

debug (test):
  extends: [.debug, .test]
  needs:
    - job: debug (build)
      artifacts: false
