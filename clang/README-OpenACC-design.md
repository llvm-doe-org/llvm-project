This document describes the current design of Clacc, which extends
Clang and LLVM with support for OpenACC.

Publications
============

This document focuses on the details of the current Clacc design and
only summarizes the design rationale.  A more complete description of
the original design rationale, including a presentation of several
design alternatives that were considered, appears in sections I
through II.D of the following paper:

> Clacc: Translating OpenACC to OpenMP in Clang, Joel E. Denny, Seyong
> Lee, and Jeffrey S. Vetter, 2018 IEEE/ACM 5th Workshop on the LLVM
> Compiler Infrastructure in HPC (LLVM-HPC), Dallas, TX, USA, (2018).

The follow paper is an earlier description of Clacc's support for the
OpenACC Profiling Interface, but some details have evolved since then:

> OpenACC Profiling Support for Clang and LLVM using Clacc and TAU,
> Camille Coti, Joel E. Denny, Kevin Huck, Seyong Lee, Allen
> D. Malony, Sameer Shende, and Jeffrey S. Vetter, Workshop on
> Programming and Performance Visualization Tools (ProTools), GA, USA
> (2020).

High-Level Design
=================

A key feature of Clacc's design is to translate OpenACC to OpenMP in
order to build on Clang's existing OpenMP compiler and runtime
support.  Clacc performs this translation at the AST level, producing
AST representations of both the original OpenACC and the generated
OpenMP.  As such, Clacc's design is depicted abstractly in the
following figure:

```
   OpenACC source
         |
         | parser
         v
    OpenACC AST
         |
         | TransformACCToOMP
         v
    OpenMP AST
         |
         | codegen
         v
      LLVM IR
         |
         | LLVM
         v
    executable
  OpenACC runtime
   OpenMP runtime
```

The components of this diagram are as follows:

* **OpenACC source** is C application source code containing OpenACC
  directives.  C++ support is under development.  Fortran support is being
  developed for Flang in a separate project.
* **Parser** is the existing Clang parser and semantic analyzer
  extended for OpenACC.
* **OpenACC AST** is a Clang AST in which OpenACC directives are
  represented by OpenACC node types, which are a Clacc extension to
  Clang.
* **`TransformACCToOMP`** is a new Clang component introduced by Clacc
  to transform OpenACC to OpenMP entirely at the AST level.
* **OpenMP AST** is a Clang AST in which OpenACC directives have been
  lowered to OpenMP directives represented by OpenMP node types, which
  exist in Clang independently of Clacc.
* **Codegen** is the existing Clang backend, which lowers the OpenMP
  AST to LLVM IR.
* **LLVM IR** is the usual LLVM intermediate representation
  generated by Clang for an OpenMP AST.
* **LLVM** consists of all LLVM optimization passes and backends that
  lower LLVM IR into object form.
* **Executable** is the final application executable.
* **OpenACC runtime** is built on top of LLVM's existing **OpenMP
  runtime** with extensions for OpenACC's run-time environment
  variables, library API, etc.

This design has a number of advantages.  First, the construction of an
OpenACC AST should facilitate the development of additional OpenACC
source-level tools, such as pretty printers, static analyzers,
lint-like tools, and debugger and editor extensions.  The construction
of an OpenMP AST should facilitate a number of non-traditional
user-level compiler features, such as automated porting of OpenACC
applications to OpenMP, and reuse of existing OpenMP tools for
OpenACC.  Because the OpenACC syntax and OpenMP syntax are so similar,
simple translations from OpenACC to OpenMP are easier to implement at
the AST level than as part of a later compiler stage.  Finally,
because the AST is the highest-level representation, implementing at
the AST level maximizes the amount of the existing OpenMP
implementation that Clacc can reuse.

It is important to understand that the above description is abstract.
Specifically, as described in the next section, `TransformACCToOMP` is
not a distinct compiler phase, and the OpenACC AST and OpenMP AST are
actually represented within a single Clang AST.

TransformACCToOMP
=================

A key issue in transforming OpenACC to OpenMP in Clang ASTs is that
Clang ASTs are designed to be immutable once constructed.  This
immutability property might at first seem to make Clacc's
`TransformACCToOMP` component impossible to implement, but it does
not.  In this section, we describe Clang's `TreeTransform` facility
and explain how `TransformACCToOMP` employs it to cleanly work around
this immutability property.

Background: TreeTransform
-------------------------

Independently of Clacc, Clang uses the `TreeTransform` facility to
transform C++ templates for the sake of instantiating them.  When the
parser reaches a template instantiation in the source code,
`TreeTransform` builds a transformed copy of the AST subtree that
represents the template, and it inserts that copy into the AST.  This
insertion is part of the normal process of extending the AST during
parsing and so does not violate AST immutability.

`TreeTransform`'s design has some convenient properties for Clacc's
purposes:

* **Extensibility**: `TreeTransform` is a class template employing the
  curiously recurring template pattern (CRTP) for static polymorphism.
  Thus, it is possible to override default behavior that is reasonable
  for C++ template instantiation but not for translation from OpenACC
  to OpenMP.
* **Encapsulation of `Sema`**: `TreeTransform`'s interface serves as a
  convenient encapsulation of semantic actions that are normally
  called during parsing.  This encapsulation enables Clacc to call
  those actions to build OpenMP ASTs without developing fragile
  dependencies on the current OpenMP implementation within `Sema`.

However, there are also some caveats to consider for `TreeTransform`:

* **Transitory semantic data**: To build new nodes, `TreeTransform`
  runs many of the same semantic actions that the parser normally
  runs.  Those semantic actions require the transitory semantic data
  that has been stored in Clang's `Sema` object by the time the parser
  reaches the syntactic context where new nodes are to be inserted,
  but the parser gradually discards some of that semantic data as the
  parser progresses to other syntactic contexts.  Thus,
  `TreeTransform` cannot be run on arbitrary nodes in the AST at
  arbitrary times.  For example, to run `TreeTransform` on arbitrary
  nodes in a translation unit after the parsing of that translation
  unit has completed, it might be necessary to transform the
  translation unit's entire AST in order to rebuild all of the
  necessary transitory semantic metadata.
* **Permanent semantic data**: Currently, parsing a C++ template
  permanently associates semantic data with that template's AST
  subtree in a way that's compatible with later runs of
  `TreeTransform` for instantiations of that template.  However,
  there's no guarantee that semantic data that is reasonable for C++
  template instantiation will be compatible with any arbitrary
  extension of `TreeTransform`.  For example, we have noticed that, if
  we write a simple `TreeTransform` extension that merely duplicates
  an OpenMP region immediately after that region's node is
  constructed, the default `TreeTransform` implementation does not
  update the declaration contexts for variable declarations that are
  local to the duplicate region (see `TreeTransform::TransformDecl`),
  so those duplicate variables appear to be declared in the original
  region, resulting in spurious compiler diagnostics.
* **Redundant AST subtrees**: As described above, `TreeTransform` is
  designed to construct modified versions of existing subtrees, and it
  is not designed to remove the original subtrees.  This behavior
  makes sense for C++ template instantiation because the original
  template must remain in the AST for additional instantiations.
  Moreover, the template and its instantiations represent distinct
  regions of the original source.  However, in the case of Clacc, an
  OpenACC subtree and the OpenMP subtree to which it is translated
  represent different versions of the same region of the source, so
  AST iterations must take special care not to visit both when they're
  expecting only one version of the source.

General Design
--------------

Clacc's `TransformACCToOMP` component is implemented as a class
derived via CRTP from `TreeTransform`.  As mentioned earlier,
`TransformACCToOMP` does not represent a distinct compiler phase.
Instead, immediately after parsing each OpenACC directive along with
any associated code region and constructing the OpenACC subtree to
represent them, Clacc passes the OpenACC subtree to
`TransformACCToOMP` to construct the corresponding OpenMP subtree.
Clacc adds the resulting OpenMP subtree to the AST, associates it with
the OpenACC subtree, and then parsing continues.  However, the manner
in which Clacc associates an OpenMP subtree with its OpenACC subtree
differs depending on whether the directive forms a statement or a
declaration.  We consider each case in the following sections.

`ACCDirectiveStmt`: Directives as Statements
--------------------------------------------

In this section, we describe how `TransformACCToOMP` handles OpenACC
directives that form C or C++ statements.  There are two kinds:

* OpenACC constructs, such as the `parallel` directive.
* OpenACC executable directives, such as the `update` directive.

For example, consider this function written in OpenACC, where comments
show the equivalent OpenMP:

```
  void foo() {
    #pragma acc parallel  // #pragma omp target teams
    #pragma acc loop gang // #pragma omp distribute
    for (int i=0; i<2; ++i)
      // loop body
  }
```

The AST that Clacc constructs is depicted below:

```
       TranslationUnitDecl
                |
           FunctionDecl
                |
           CompoundStmt
                |
       ACCParallelDirective
                |          `-OMPNode-> OMPTargetTeamsDirective
         ACCLoopDirective                         |
              /   \      `---OMPNode---> OMPDistributeDirective
  ACCGangClause   ForStmt                         |
                     |                         ForStmt
                                                  |
```

Clacc's `ACCDirectiveStmt` is a base class for any node representing
an OpenACC directive that forms a statement, such as the
`ACCParallelDirective` and `ACCLoopDirective` in the above example.
`OMPExecutableDirective`, which also exists upstream, is a base class
for any corresponding OpenMP node, such as the
`OMPTargetTeamsDirective` and `OMPDistributeDirective` in the above
example.  Clacc's `DirectiveStmt` is a base class for both
`ACCDirectiveStmt` and `OMPExecutableDirective`.

Each such directive node serves as the root of a subtree that also
contains any associated statement.  In the above example, the
associated statement of the `ACCParallelDirective` is the
`ACCLoopDirective`, whose associated statement is a `ForStmt`.  The
associated statement of the `OMPTargetTeamsDirective` is the
`OMPDistributeDirective`, whose associated statement is the other
`ForStmt`.

Inserting an `ACCDirectiveStmt` and its `OMPExecutableDirective` into
the Clang AST as siblings would yield confusing semantics for analysis
tools, implying both statements are to be executed in sequence.  Thus,
as in the above example, `TransformACCToOMP` instead adds an
`OMPExecutableDirective` as a hidden child of an `ACCDirectiveStmt`.
The `OMPExecutableDirective` can be retrieved using the `getOMPNode`
member function of the `ACCDirectiveStmt`.

`TransformACCToOMP` translates directives bottom-up.  Thus, in the
above example, `TransformACCToOMP` first duplicates the `ForStmt` and
its subtree.  Then, it translates the `ACCLoopDirective` to an
`OMPDistributeDirective`, which becomes the normal parent for the
translated `ForStmt` and the hidden OpenMP child for the
`ACCLoopDirective`.  Finally, it translates the `ACCParallelDirective`
to an `OMPTargetTeamsDirective`, which becomes the normal parent for
the `OMPDistributeDirective` and the hidden OpenMP child for the
`ACCParallelDirective`.

`ACCDeclAttr`: Declarative Directives as Attributes
---------------------------------------------------

In this section, we describe how `TransformACCToOMP` handles OpenACC
declarative directives.  So far, Clacc supports the following
declarative directives:

* The `routine` directive.

For example, consider this declaration written in OpenACC, where
comments show the equivalent OpenMP:

```
  #pragma acc routine seq // #pragma omp declare target
  void foo();
  // #pragma omp end declare target
```

The AST that Clacc constructs is depicted below:

```
                 TranslationUnitDecl
                          |
                     FunctionDecl
                    /            \
  ACCRoutineDeclAttr --OMPNode--> OMPDeclareTargetDeclAttr
          |                                  |
         Seq                     IsOpenACCTranslation=true
```

Clacc's `ACCDeclAttr` is a base class for any attribute node
representing an OpenACC declarative directive, such as the
`ACCRoutineDeclAttr` in the above example.  Clacc's `OMPDeclAttr` is a
base class for any corresponding OpenMP attribute node, such as the
`OMPDeclareTargetDeclAttr` in the above example.  `InheritableAttr`,
which also exists upstream, is a base class for both `ACCDeclAttr` and
`OMPDeclAttr` in Clacc.  `Decl`, which also exists upstream, is a base
class for associated declaration nodes, such as the `FunctionDecl` in
the above example.

Unlike a directive that forms a statement, a declarative directive is
not represented in a Clang AST as the root node of a subtree that also
contains the associated code.  Instead, it is represented as an
attribute node attached to an associated declaration.  Moreover,
`TransformACCToOMP` inserts an `ACCDeclAttr` and its `OMPDeclAttr`
into the Clang AST as siblings: both are attached directly to the same
`Decl`.  In the above example, the `ACCRoutineDeclAttr` and
`OMPDeclareTargetDeclAttr` are both attached to the `FunctionDecl`.

If, instead, `TransformACCToOMP` were to store an `OMPDeclAttr` as a
hidden child of an `ACCDeclAttr`, as it does for an
`OMPExecutableDirective` and `ACCDirectiveStmt`, significant
refactoring of the existing OpenMP semantic analysis and LLVM IR
codegen implementation would be required for those analyses to find
the `OMPDeclAttr`.  The reason is that, unlike Clang's implementation
for statements, Clang's implementation for OpenMP attributes does not
have a few large switches or if-then-else blocks over node kinds that
can easily be extended for new node kinds.  Instead, it retrieves
specific attributes at many points throughout the implementation.

Nevertheless, `TransformACCToOMP` does record the relationship between
an `ACCDeclAttr` and its `OMPDeclAttr`.  First, like
`ACCDirectiveStmt`, `ACCDeclAttr` has a `getOMPNode` member function,
which retrieves the `OMPDeclAttr`.  Second, `OMPDeclAttr` has a
`getIsOpenACCTranslation` member function, which returns true to
indicate that it does not represent an OpenMP directive appearing in
the original source code.  These properties make it easier for
analyses, in particular AST printing and source-to-source translation,
to select which attribute nodes to visit and what their relationship
is.  That is, they can do so without having to maintain a separate
encoding of the general mapping that `TransformACCToOMP` already
maintains between OpenACC and OpenMP declarative directives.

In some cases, `TransformACCToOMP` determines that an OpenACC
declarative directive should simply be discarded when translating to
OpenMP.  In this case, an `ACCDeclAttr` has no corresponding
`OMPDeclAttr`, and its `directiveDiscardedForOMP` member function returns true.

If an OpenACC declarative directive is syntactically attached to a
declaration, then the directive's `ACCDeclAttr` and any `OMPDeclAttr`
are attached to the `Decl` for that declaration.  Otherwise, the
directive's `ACCDeclAttr` and any `OMPDeclAttr` are attached to the
`Decl` for the associated symbol's most recent declaration when Clang
determined the `ACCDeclAttr`.  In either case, a result is that the
`ACCDeclAttr` and any `OMPDeclAttr` are inherited by the `Decl` for
any declaration of the symbol in the remainder of the translation
unit.

`TreeTransform` Caveats and AST Traversals
------------------------------------------

Clacc overcomes the `TreeTransform` caveats discussed in the section
"Background: TreeTransform" as follows:

* **Transitory semantic data**: Because Clacc calls
  `TransformACCToOMP` immediately after constructing an OpenACC
  subtree, the exact transitory semantic data needed to construct the
  corresponding OpenMP subtree is present.
* **Permanent semantic data**: So far, Clacc is able to override
  specific `TreeTransform` functionality in order to transform
  semantic data that would be permanent across C++ template
  instantiation but that must be different between OpenACC and OpenMP
  subtrees.
* **Redundant AST subtrees**: AST traversals are typically based on
  Clang's `RecursiveASTVisitor` facility.  Most AST traversal
  developers and users likely expect for traversals to visit an AST
  representing the original source code only.
    * `ACCDirectiveStmt`: Because the `OMPExecutableDirective` to
      which an `ACCDirectiveStmt` is translated is not recorded as a
      normal child of the `ACCDirectiveStmt`, `RecursiveASTVisitor`
      visits the `ACCDirectiveStmt` but skips its hidden
      `OMPExecutableDirective` child.  However, while visiting an
      `ACCDirectiveStmt`, a visitor can be written to call its
      `getOMPNode` member function to access the
      `OMPExecutableDirective`, possibly for a recursive visitation.
    * `ACCDeclAttr`: If an AST traversal should visit only the
      original OpenACC source, it must be implemented to ignore any
      `OMPDeclAttr` whose `getIsOpenACCTranslation` returns true.
      Fortunately, an `ACCDeclAttr` and its `OMPDeclAttr` have no
      redundant children that an AST traversal might mistakenly
      recurse into.

As a result, Clacc supports at least three kinds of AST traversals:

* **Visit OpenACC only**: For example, `-ast-print` is an existing
  Clang command-line option for translating the Clang AST back to
  source.  Because the output of `-ast-print` has thus always
  corresponded to the original preprocessed input and never a lowered
  version of it, Clacc extends it for OpenACC not to include the
  OpenMP translation.  In the examples from the previous two sections,
  `-ast-print` thus visits the `ACCParallelDirective`, the
  `ACCLoopDirective`, the original `ForStmt` subtree, and the
  `ACCRoutineDeclAttr` but not the `OMPTargetTeamsDirective`, the
  `OMPDistributeDirective`, the translated `ForStmt` subtree, or the
  `OMPDeclareTargetDeclAttr`.
* **Delegate to OpenMP**: For example, one of the major motivations
  for translating the OpenACC AST to an OpenMP AST is to reuse the
  existing LLVM IR codegen implementation for OpenMP.  Thus, for LLVM
  IR codegen, each `ACCDirectiveStmt` delegates to its hidden
  `OMPExecutableDirective` child, and each `ACCDeclAttr` is skipped in
  favor of its `OMPDeclAttr`.  In the previous examples, the
  `ACCParallelDirective` delegates LLVM IR codegen to the
  `OMPTargetTeamsDirective` and its subtree, and the normal subtree of
  the `ACCParallelDirective` is not visited.  The `ACCRoutineDeclAttr`
  is ignored, and normal OpenMP codegen is performed for the
  `OMPDeclareTargetDeclAttr`.
* **Visit OpenACC and OpenMP**: For example, `-ast-dump` is an
  existing Clang command-line option for printing a textual
  representation of the AST structure, including parent-child
  relationships, source location information, and computed types.
  This feature is clearly designed for debugging ASTs and is very
  useful for Clang developers.  For each `ACCDirectiveStmt`, Clacc
  extends this feature to always produce a full representation of that
  node's subtree including, as a specially marked child, the OpenMP
  subtree to which it translates.  Clacc also adds a representation of
  each `ACCDeclAttr`, including the kind of its `OMPDeclAttr`, which
  is printed as a separate attribute, including its
  `IsOpenACCTranslation` property.

Redundant AST nodes might at first seem to be a disadvantage of
employing `TreeTransform` in `TransformACCToOMP`.  However, because it
results in a representation of the chosen mapping from OpenACC to
OpenMP, we believe it augments the potential for constructing flexible
debugging and analysis tools on top of Clacc.  The capabilities of
`-ast-dump`, as described above, and `-fopenacc-print`, as described
in the section "Source-to-Source Translation", are simple examples.

Codegen
=======

As mentioned in the previous section, an OpenACC AST node of type
`ACCDirectiveStmt` implements LLVM IR codegen by delegating to its
hidden OpenMP child.  The most obvious points for this implementation
are the OpenACC cases in the main switch on AST node types within
Clang codegen's `CodeGenFunction::EmitStmt`.

While necessary, those implementation points are insufficient for offloading
support.  The issue is that the OpenMP codegen implementation also has a hook
into Clang's codegen framework outside that switch.  This hook calls
`CGOpenMPRuntime::scanForTargetRegionsFunctions`, which recurses through AST
nodes looking for OpenMP target regions to emit in separate device functions.
Thus, Clacc extends this scan to look for OpenACC AST nodes and, as before, to
delegate the required codegen to their hidden OpenMP children.  Finally, Clacc
extends the class `CheckVarsEscapingDeclContext` in `CGOpenMPRuntimeCPU.cpp`
with a visit member function for `ACCDirectiveStmt` that delegates to the hidden
OpenMP child.

Clacc makes no changes to LLVM IR codegen for the sake of
`ACCDeclAttr` nodes, which are thus ignored.  The corresponding
`OMPDeclAttr` nodes are seen directly by codegen and are handled as
they would be in an OpenMP program.

Source-to-Source Translation
============================

The `TransformACCToOMP` section above described how Clacc uses Clang's
`TreeTransform` facility to construct OpenMP subtrees and associate
them with OpenACC subtrees.  It also mentioned that `-ast-print`
prints only OpenACC.  In this section, we describe Clang's `Rewrite`
facility, which is normally used in Clang for source-to-source
translation, and we describe how Clacc prints OpenMP source.

Background: Rewrite
-------------------

The `Rewrite` facility in Clang is used in tools like `clang-format`
and `clang-tidy` to perform source-to-source translation.  However,
`Rewrite` does not perform AST transformations.  Instead, `Rewrite`
provides an API for making textual modifications to Clang's input
buffer, which contains the original input source code, while using the
Clang AST to guide those modifications.

To produce a transformed AST, the transformed source from `Rewrite`
must be parsed anew by Clang to construct an entirely separate AST.
For this reason, `Rewrite` is most useful for implementing a single
transformation pass whose output is source.  `Rewrite` is not
efficient for successive transformation passes or for LLVM IR codegen.
Direct AST transformations are better for those purposes.

Because traditional OpenACC compilation is a major use case for Clacc,
and because for Clang that requires LLVM IR codegen, we chose
`TreeTransform` not `Rewrite` to implement `TransformACCToOMP`.
However, source-to-source translation is also a Clacc use case, and,
as discussed in the next section, `Rewrite` is helpful there after
`TransformACCToOMP`.

Design
------

To enable source-to-source translation from the Clang command line,
Clacc supports two new Clang command-line options: `-fopenacc-print`,
which is built on `Rewrite`, and `-fopenacc-ast-print`, which is built
on `-ast-print`.  Each takes any of the following values:

* `acc`: OpenACC directives are printed and the OpenMP directives to
  which they were translated are ignored.  Thus, this value is likely
  not helpful to users but can be helpful to developers for debugging
  the Clacc implementation.  That is, `-fopenacc-print=acc` merely
  prints the original source without modification, and
  `-fopenacc-ast-print=acc` is a more convenient form of
  `-Xclang -ast-print -fsyntax-only -fopenacc`.
* `omp`: OpenMP directives are printed, and the OpenACC directives
  from which they were translated are ignored.
* `acc-omp`: OpenACC directives are printed and the OpenMP directives
  to which they were translated are printed in neighboring comments.
* `omp-acc`: OpenMP directives printed and the OpenACC directives from
  which they were translated are printed in neighboring comments.

In the last two cases, Clacc will avoid duplicating the code block
associated with a directive if that code block prints identically in
both the OpenACC and OpenMP versions.  The output then looks similar
to the code passages in the examples in the `TransformACCToOMP`
section.

Originally, Clacc only supported the functionality of
`-fopenacc-ast-print` (but under a different name).  Because it's
built on `-ast-print`, its functionality is problematic in several
ways:

* `-ast-print` was designed for debugging and not for faithful
  printing of the AST.  Even so, we have successfully contributed
  upstream a number of fixes to improve the fidelity of its output on
  the grounds that such fixes also improve the debugging use case.
  Still, our hunch is that there is likely much more work to do,
  especially in the case of C++ as we have mostly focused on C so far.
* Because `-ast-print` computes its output from the AST structure, the
  output looks like the output of Clang's preprocessor.  Thus,
  includes and other macros are expanded, and the original formatting
  and comments are lost.  Such mangling of the source is unsuitable
  for permanent migration of an application from OpenACC to OpenMP.
  It's also unsuitable when targeting a different OpenMP compiler
  perhaps for a different target architecture where preprocessor
  macros and includes expand differently.

On the other hand, because `-fopenacc-print` is built on `Rewrite`, it
modifies the original input buffer and thus can avoid these problems
in most cases.  That is, `-fopenacc-print` examines the OpenACC
subtrees and the OpenMP subtrees computed by `TransformACCToOMP` as
needed to modify the input buffer in the manner requested by the
argument to `-fopenacc-print`.

Limitations
-----------

For OpenMP subtrees containing directives and other code not appearing
in the original source and thus not in the input buffer,
`-fopenacc-print` still employs `-ast-print` functionality.  Thus, the
`-fopenacc-ast-print` problems mentioned in the previous section are
still present within the OpenMP constructs in the source produced by
`-fopenacc-print`, but at least they are not pervasive throughout the
rest of the generated source.  In the future, we might experiment with
using some means such as source locations to track which portions of
an OpenMP subtree were copied verbatim from the OpenACC subtree and
then overriding `-ast-print` functionality to print just those
portions using the original input buffer.

The `Rewrite` facility is challenging to use when either boundary of a
region of text to be rewritten is expanded from a preprocessor macro.
See the section "Source-to-Source Mode Limitations" in
`README-OpenACC-status.md` for details on how this currently limits
`-fopenacc-print`.

OpenACC Directive within C++ Templates
======================================

Clacc's support for OpenACC directives appearing within C++ templates is in its
infancy.  This section discusses related design principles and caveats, but
these will likely evolve as support grows.

Background: TreeTransform Member Functions
------------------------------------------

As discussed in the section "TransformACCToOMP" above, Clang uses
`TreeTransform` to transform C++ templates for the sake of instantiating them.
Specifically, Clang derives `TemplateInstantiator` from `TreeTransform` for this
purpose.

Within `TreeTransform`, for each kind of AST node, a member function must be
implemented to call the same `Sema` actions the parser normally calls to build
that AST node.  The difference from the parser is the input: instead of textual
source code, the input consists of (1) the template's corresponding AST node,
which is passed as an argument to the `TreeTransform` member function, and (2)
template arguments and other instantiation-specific information, which are
contained with the `TemplateInstantiator` object.

In contrast, `TreeTransform` is not used for a template specialization providing
a new template definition, which is instead parsed into new AST nodes.

For OpenACC AST nodes, such as `ACCParallelDirective`, Clacc adds
implementations for associated `TreeTransform` member functions, such as
`TransformACCParallelDirective`.  The remainder of this section describes Clacc
design principles governing the relationship between these member functions and
OpenACC actions in `Sema`.

Assume Conformance Where Undefined
----------------------------------

While parsing an original template or a partial template specialization, if
missing actual template arguments are required to determine whether OpenACC
directives violate a restriction, Clacc's OpenACC `Sema` actions assume there is
no violation, skip associated diagnostics, and continue building the AST.  Where
a template is instantiated, such undefined cases are eliminated.  As discussed
above, Clacc's `TreeTransform` member functions then perform the `Sema` actions
again and thus diagnose any violation of the restriction.  Where a restriction
violation can be determined in a template despite missing template arguments,
rather than waiting for template instantiations, Clacc's `Sema` actions diagnose
it immediately in the template where the diagnostic is more helpful to the user.

For example:

```
template <typename T>
void f(T x) {
  #pragma acc parallel copy(x) // implicit reduction(+:x)
  #pragma acc loop gang worker vector reduction(+:x)
  for (int i = 0; i < N; ++i)
  x += N;
}
void g(int i)  { f(i); }
void h(int *p) { f(p); } // error: OpenACC reduction operator '+' argument must be of arithmetic type
```

While parsing the template function `f`, Clacc's `Sema` actions assume `T` is
compatible with the reduction operator `+` on the `loop` construct.  While
instantiating `f` for its use in `g`, they verify that `int` is indeed
compatible.  However, while instantiating `f` for its use in `h`, they report an
error diagnostic that `int *` is not compatible, and they then discard the
explicit `reduction` on the `loop` construct as a result.

TODO: In some cases, Clacc does not yet implement detection of template argument
dependencies and thus reports error diagnostics when it shouldn't in the
template.

Discard AST Nodes Computed for Templates
----------------------------------------

The implementation of any of Clacc's `TreeTransform` member functions is mostly
straightforward.  It extracts properties from the template's AST node and calls
`Sema` actions to build the template instantiation's corresponding AST node from
those properties.  When such a property is another AST node, it normally calls
an appropriate `TreeTransform` member function to recurse and rebuild it first.

However, that recursion is usually sufficient only for AST nodes that correspond
to explicit source code.  AST nodes computed by the OpenACC semantic analysis
must be recomputed from scratch to consider the impact of the template
arguments.  Specifically:

* Clacc's `TreeTransform` member functions ignore the predetermined and
  implicitly determined clauses previously computed for a template.  Doing so
  permits the `Sema` actions for the associated OpenACC directive to recompute
  the clauses from scratch for the template instantiation.
* After building the OpenACC directive's new AST node with new such clauses, it
  calls `TransformACCToOMP` to recompute its OpenMP node in terms of them.

For example, in `f` in the previous example, Clacc's `Sema` actions for the
`parallel` construct compute an implicit `reduction` clause to indicate that the
`loop` construct's gang reduction is effectively performed there ("Semantic
Clarifications" later in this document explains implicit `reduction` clauses).
However, in the instantiation of `f` within `h`, because the explicit
`reduction` clause on the `loop` construct is found to have a type compatibility
error, Clacc's `Sema` actions for the `parallel` construct now do not compute
the implicit `reduction` clause.  It is important here that Clacc's
`TreeTransform` member function for the `parallel` construct ignores the
implicit `reduction` clause from the original template because recursing and
rebuilding it with `TreeTransform` would trigger the same type compatibility
diagnostic again except it would be for a bogus `reduction` clause that the user
cannot see.

Traditional Compilation vs. Source-to-Source Mode
-------------------------------------------------

For traditional compilation, it might seem that computing the implicit
`reduction` clause for the original template `f` in the previous example is
never useful.  That is, LLVM IR codegen is not performed for the original
template but only for its instantiations, so computing implicit clauses might
seem useful only for instantiations to translate to OpenMP before performing
LLVM IR codegen.  Even so, implicit clauses are often important for subsequent
OpenACC analysis, which can sometimes be useful to produce diagnostics
immediately at the template.

For source-to-source mode, the reverse is true: OpenMP source is generated for
the original template and not for its instantiations.  Thus, OpenACC implicit
clauses are needed in the original templates in order to translate to OpenMP
before printing OpenMP source.  Unfortunately, without the type information
provided by template arguments, some OpenACC implicit clauses cannot be
computed.  In the current implementation, this issue sometimes prevents
source-to-source mode from behaving correctly.  A couple of possible approaches
to solving this problem are as follows, but neither has been implemented:

* In the original templates, somehow generate OpenMP directives that encode
  OpenACC's general implicit clause rules.  For example, we might rely on
  OpenMP's implicit clause rules where sufficient and add OpenMP's `defaultmap`
  clause for other cases.  However, before supporting C++, Clacc's approach has
  been not to rely on implicit clauses in the OpenMP translation when possible,
  as discussed under "Explicit vs. Implicit OpenMP Clauses" below, so we have
  not investigated exactly what an encoding of the general rules would look
  like in OpenMP.
* For template instantiations, generate explicit template specializations
  containing the OpenMP directives.  However, even in the simple example above,
  it is not clear where those specializations should be inserted in the
  translation, and it is still not clear what the original template should look
  like in the translation.  Furthermore, imagine an elaborate template class
  appearing in a header file and instantiations appearing in many compilation
  units.  Replicating that class in template specializations throughout all the
  compilation units is surely not what the source-to-source mode user would
  want.  They likely just want the OpenACC directives to be translated to OpenMP
  in their original source locations within the original template.

Interaction with OpenMP Support
===============================

`-fopenmp`
----------

Even though Clacc translates OpenACC to OpenMP, Clacc currently does
not support OpenACC and OpenMP in the same source.  Doing so would
require, for example, extensions to data attribute analyses to
consider the interactions between OpenACC and OpenMP directives and
clauses.  Thus, Clacc reports an error diagnostic if `-fopenmp` is
specified on the Clang command line when OpenACC support is enabled by
any `-fopenacc*` option.  To implement this, Clacc extends the Clang
driver to just pass the relevant command-line options to the Clang
front end, and it extends the front end to produce the error
diagnostic.  Thus, specifying `-cc1` to bypass the driver does not
avoid the error diagnostic.

Discarding OpenMP (`-Wsource-uses-openmp`)
------------------------------------------

As usual when `-fopenmp` is not specified, the front end discards
OpenMP directives in the application source during parsing, and
`-Wsource-uses-openmp` is available as usual to request warnings about
them.  Nevertheless, Clacc must enable OpenMP support in the front end
in order to build OpenMP subtrees without failing many assertions in
the OpenMP implementation, but enabling OpenMP support normally
prevents OpenMP directives from being discarded.  Moreover, OpenMP
directives in system headers must be parsed for correct codegen from
the OpenMP translation.  In particular, OpenMP variant directives are
used in (1) the `acc_on_device` implementation in Clacc's `openacc.h`,
and (2) the OpenMP wrappers LLVM provides for some system headers when
compiling for certain offloading devices.

To implement all this, Clacc extends the front end as follows:

* After confirming the user did not request both OpenACC and OpenMP
  support, Clacc enables OpenMP support if OpenACC support is enabled.
* During parsing, Clacc discards any OpenMP directive if either (1)
  OpenMP support is disabled or (2) OpenACC support is enabled and an
  OpenMP directive does not appear in a system header.

This design is confusing and has at least one bug: when OpenACC is
enabled, `_OPENMP` is defined everywhere as if OpenMP is enabled
everywhere.  We are thinking of changing this design in the future.
First, the front end would fully disable OpenMP everywhere when
OpenACC is enabled, and we would develop an alternate mechanism to
disable assertions while building OpenMP subtrees.  Second, we would
add OpenACC wrappers equivalent to existing OpenMP wrappers for system
headers, and, in place of the variant directives, they would use
OpenACC equivalents (perhaps OpenACC extensions) or compiler builtins.
Third, `acc_on_device` would become a compiler builtin rather than
being fully defined in `openacc.h`.  The front end would translate
such OpenACC equivalents and compiler builtins to the OpenMP forms
used now.

`-fopenmp-*`
------------

Clacc permits all `-fopenmp-*` command-line options when OpenACC
support is enabled.  These options adjust various OpenMP features when
compiling the OpenMP translation.  To implement this, Clacc extends
Clang to check if OpenACC support is enabled everywhere it already
checks if OpenMP support is enabled.  However, so far, only
`-fopenmp-targets=<triples>` to specify desired offloading targets has
been tested, and it's only been tested for traditional compilation
mode.

It's not clear if `-fopenmp-*` options should be relevant to
source-to-source mode.  First, some options like
`-fopenmp-targets=<triples>` affect the OpenMP version Clang selects
by default, and that can affect semantics, diagnostics, and any
AST-printed code containing `_OPENMP`, but should Clacc let any of
that matter when compiling OpenACC?  Second, in experimental
implementations, we have observed that `-fopenmp-targets=nvptx64` adds
many declarations to the source code printed for `nvptx64`.  Would
offload bundling of the various versions of the source code be useful?

In general, the Clacc user should not have to be aware that OpenMP
support is being utilized when in traditional compilation mode.
However, the need to combine `-fopenmp-targets=<triples>` with
`-fopenacc` to enable offloading, for example, violates that
principle.  Moreover, diagnostics for `-fopenmp-*` are currently
expressed in terms of OpenMP even when OpenACC support is enabled.  In
the future, especially when Clacc is considered for upstreaming, Clacc
might develop its own `-fopenacc-*` options to be used instead.
Nevertheless, for now, we have concluded that the Clacc implementation
will be easier to keep in sync with upstream while the Clacc
implementation reuses the existing `-fopenmp-*` options with minimal
modifications.

`-fopenmp=<lib>`
----------------

Normally, `-fopenmp=<lib>` can be used to specify an alternate OpenMP
library.  However, Clang handles it as an alias for `-fopenmp`, so
it's also expected to enable OpenMP support.  We feel it would be
subtle and surprising to users if Clacc were to suppress the latter
behavior when OpenACC support is enabled, so it is currently not
possible to use `-fopenmp=<lib>` to specify an alternate OpenMP
library when OpenACC support is enabled.  Options like `-L` and `-l`
must be used instead.

OpenACC to OpenMP Mapping
=========================

This section details Clacc's mapping from OpenACC directives and
clauses to OpenMP directives and clauses.  If an OpenACC directive or
clause does not appear in this section, we haven't implemented it yet.
`README-OpenACC-status.md` also lists which OpenACC directives and
clauses Clacc currently implements.

Notation
--------

For conciseness, we use the following notation when describing clauses
and data attributes:

* *exp* labels a clause, possibly specifying a data attribute, that is
  explicitly specified in the source.
* *pre* labels a data attribute that is predetermined by the compiler
  (that is, cannot be overridden by an *exp* clause) and is not
  specified by an *exp* clause.
* *imp* labels a data attribute that is implicitly determined by the
  compiler (that is, can be overridden by an *exp* clause) and is not
  specified by an *exp* clause.
* *not* labels a clause that is not *exp*.
* The notation *L C* -> *L' C'* specifies that clause or data
  attribute *C* under the condition identified by label *L* maps to
  clause or data attribute *C'* under the condition identified by
  label *L'*, where a label is *exp*, *pre*, *imp*, or *not*.
* The notation *L*|*L' C* -> *L'' C'* specifies both of the following
  mappings:
    * *L C* -> *L'' C'*
    * *L' C* -> *L'' C'*
* Mappings for per-variable data attributes and clauses are per
  variable and per directive.
* Mappings for other clauses are per directive.
* Where arguments to clauses are not specified on either end of the
  mapping, the mapping maintains the arguments as they are even if the
  clause name or position changes.

Prescriptive vs. Descriptive OpenACC
------------------------------------

The mapping in this section represents a conservative choice intended
to always achieve correct OpenACC behavior.  As Clacc evolves to
support a descriptive interpretation of OpenACC and the requisite
compiler analyses, this mapping will represent the base choice from
which Clacc will look for deviations to improve performance of the
application, and this mapping will represent the fall back choice if
Clacc fails to find better mappings.  Under Clacc's current
prescriptive interpretation of OpenACC, Clacc supports no such
analyses and so effectively always falls back to this mapping.

Explicit vs. Implicit OpenMP Clauses
------------------------------------

One theme throughout Clacc's mapping is that Clacc does not rely on
implicit or predetermined attributes of OpenMP except for cases where
an explicit clause is not permitted or is difficult to produce.  That
is, Clacc tries to make the exact behavior it intends to produce as
explicit as possible in the generated OpenMP for the sake of
debugging.  Thus, -> *exp* appears frequently below.

Clause Aliases
--------------

Some OpenACC clauses, such as `pcopy`, are aliases for others clauses,
such as `copy`.  Clacc handles the semantics and mapping for a clause
alias the same as for the aliased clause, so clause aliases are not
documented further in this section.

Semantic Clarifications
-----------------------

While developing this mapping, we found we had to make assumptions
about some aspects of OpenACC semantics in C that are not clear in the
OpenACC specification.  In many cases, it was the related behavior of
the Clang OpenMP implementation that brought the need for those
assumptions to our attention.  We describe those assumptions in this
section.  We are working with the OpenACC technical committee to
clarify these points in future versions of the OpenACC specification.

### Basic Data Attributes ###

* Clacc models data attributes (DAs) by partitioning them into two
  groups:
    * Data mapping attributes (DMAs), which describe the mapping and
      transfer of data between host and device:
        * `nomap` (default)
        * `present`
        * `copy`
        * `copyin`
        * `copyout`
        * `create`
        * `no_create`
        * `delete`
        * Others not yet implemented by Clacc.
    * Data sharing attributes (DSAs), which describe the sharing of
      data among gangs, workers, or vector lanes:
        * `shared` (default, mappable)
        * `reduction` (mappable)
        * `firstprivate` (unmappable)
        * `private` (unmappable)
    * DA combinations:
        * Every variable has at most one DMA and one DSA on a
          directive.
        * Mappable DSAs can be combined with any DMA.
        * Unmappable DSAs can be combined with `nomap` but no other
          DMA.
        * The restrictions for *exp* DAs that enforce these rules are
          discussed later in this section.
    * Relevant DAs:
        * A variable cannot have any DA from a group on a directive if
          that group is irrelevant to that directive.
        * DMAs are relevant only to `acc enter data`, `acc exit data`,
          `acc data`, and `acc parallel`.
        * DSAs are relevant only to `acc parallel` and `acc loop`.
        * Relevance does not indicate that all members of a group are
          permitted.  For example, `firstprivate` is not permitted on
          `acc loop`, and `copyout` is not permitted on `acc enter
          data`.
    * Default DA:
        * Each group has one default DA.
        * It is not permitted as *exp* and is never computed as *pre*.
        * It is computed as *imp* for a variable on a directive if all of the
          following are true:
            * The OpenACC specification actually specifies *imp* DAs at all for
              that kind of directive (e.g., `acc parallel` and `acc loop`).
            * The group is relevant to the directive.
            * The variable is referenced within the directive's associated
              statement and declared outside it.
            * There is no other *exp*, *pre*, or *imp* DA from that group for
              that variable on that directive.
            * If the variable is a member expression (e.g., `s.x`), then (1) it
              has an *exp* DA of either group visible at the directive, and (2)
              its base expression (e.g., `s`) has no *exp* DA of either group on
              the directive.
        * `nomap` indicates no data mapping of a variable between
          device and host.
        * `shared` indicates no privatization of a variable.  That is,
          references to the variable within the construct refer to a
          single variable that is shared among the gangs, workers, or
          vector lanes executing the construct.
    * Notes:
        * The OpenACC 3.1 specification does not categorize DAs into
          these groups, and this categorization is not strictly
          necessary to specify OpenACC semantics unambiguously.
          However, Clacc employs this categorization as it seems to
          simplify and clarify documentation, discussion, and
          implementation.
        * The OpenMP 5.1 specification does employ these two groups
          with the same high-level semantics (but the DAs within the
          groups are not precisely the same as in Clacc).  Thus,
          additional benefits of employing this categorization in
          Clacc are that it might prove recognizable to potential
          Clacc contributors and that it facilitates OpenACC
          translation to OpenMP.
        * The default DA in each group is not specified as a DA by
          OpenACC 3.1:
            * As noted in the mappings below, Clacc's translation
              sometimes discards `nomap`, which is then merely a
              placeholder indicating no mapping attribute was
              determined.  However, Clacc sometimes translates it to
              suppress OpenMP's *imp* DAs, which do not always have
              the desired semantics.
            * As noted in the mappings below, Clacc's translation discards
              `shared`.  However, it assists in determining when the translation
              should not discard `nomap` because `shared` means no other DSA was
              determined.
        * Otherwise, the DMAs are listed in OpenACC 3.1 sec. 2.7 "Data
          Clauses", and the DSAs are described in the sections for the
          directives that permit them.
        * The constraints above for a member expression check that the
          application programmer has (1) chosen to specify DAs for the specific
          member at some point and (2) not chosen to specify DAs for the entire
          base on the current directive.  If condition 1 is met but condition 2
          is not, and if the compiler were to add *imp* default DAs for the
          member to the current directive anyway, those *imp* default DAs might
          contradict the application programmer's DA there.  For example, given
          `acc data copy(s.ptr)` enclosing an `acc parallel no_create(s)`, what
          happens if the compiler adds *imp* `nomap(s.ptr)` to the latter?  At
          least at one point in Clacc's history, `nomap(s.ptr)` translated to
          something like `map(s.ptr)` because, in other scenarios, it's
          necessary to override OpenMP's implicit attribute (`map(s.ptr[0:0])`,
          which is wrong for OpenACC semantics).  That combined with
          `map(ompx_no_alloc,ompx_hold,alloc:s)` during codegen such that, at
          run time, it ignored the `ompx_no_alloc` for the entire `s` and
          complained about an array extension error when the rest of `s` was not
          already mapped.  There might have been multiple ways to fix this, but
          the simplest at the time seemed to be to avoid the contradictory *imp*
          `nomap(s.ptr)`.  That is, the application programmer's `no_create(s)`
          on `acc parallel` applies to `s.ptr` too, and the compiler shouldn't
          contradict it by saying `s.ptr` is not mapped there.
* It is an error if, on any OpenACC directive, a variable appears more
  than once per *exp* DA.  Notes:
    * The main motivation for this error is that such redundancy is
      likely a mistake.
    * gcc 7.4.0 also reports errors for this case, but pgcc 19.4-0
      does not.
    * OpenMP 5.0 sec. 2.19.4 p. 282 L7-9 says, "A list item may not
      appear in more than one clause on the same directive, except
      that it may be specified in both firstprivate and lastprivate
      clauses."  Thus, if Clacc did not report such duplicate clauses
      as errors, it would have to discard them when generating OpenMP.
* It is an error if, on any OpenACC directive, a variable appears in
  more than one *exp* DMA.  Notes:
    * In OpenACC 3.1, it seems clear that DMAs are intended to be
      mutually exclusive options along a single dimension.  For
      example, `copy`, `copyin`, and `copyout` have contradictory
      specifications for initialization of the local copy of the
      variable and for storing data back to the original variable.
    * No *pre* DMA is specified by OpenACC 3.1 or implemented by
      Clacc.
* It is an error if, on any OpenACC directive, a variable appears in
  more than one *exp*|*pre* DSA.  Notes:
    * On a non-combined directive, DSAs have contradictory
      specifications for initialization of the local copy of the
      variable and for storing data back to the original variable.
    * On a combined directive, `firstprivate` applies to the effective
      `acc parallel`, but `reduction` and `private` apply to the
      effective `acc loop`.  Thus, specifying a variable in both
      `firstprivate` and either `reduction` or `private` on a combined
      directive might not seem contradictory.  However, it is surely a
      mistake.  In the case of `reduction`, you cannot access the
      reduced value.  In the case of `private`, you cannot access the
      initialized value.  Thus, the above restriction fully applies to
      a combined directive as well.
* It is an error if, on any OpenACC directive, a variable appears in
  an *exp* DMA and an unmappable *exp* DSA.  Notes:
    * Due to variable privatization within the construct, unmappable
      DSAs appear to circumvent the benefits of any reference
      counting, allocations, or data transfers specified by a DMA on
      the same directive.
    * That seems equally true on a combined directive even though DMAs
      apply to the effective `acc parallel` while `private` applies to
      the effective `acc loop`.
    * The only mappable *exp* DSA is `reduction`.  In OpenACC 3.1, it
      is specifically meant to combine with DMAs and even implies a
      DMA, `copy`.
    * TODO: Does any existing OpenACC code combine a DMA with either
      `firstprivate` or `private` expecting the non-privatized device
      copy to be accessed elsewhere or via an alias even though it's
      inaccessible (lexically) within the construct?
* *exp*|*imp* DA for a variable of incomplete type is an error.
  Notes:
    * A private or device copy is assumed to be allocatable in each of
      these cases, but creating a new allocation or checking for a
      full existing allocation is impossible for incomplete types
      because the size is unknown.
    * It does not appear possible for any DA other than `copy`,
      `nomap`, or `shared` to be *imp* for a variable of incomplete
      type.
* *exp* `copyout`, *exp* `create`, *exp* `private`, or *exp*
  `reduction` for a `const` variable is an error.  Notes:
    * There are several reasons:
        * Except in the case of `reduction`, device/private copies
          would remain uninitialized throughout their lifetimes
          because the application is not permitted to write to them.
        * A `reduction` is pointless if the application cannot write
          to the private copies after initialization.
        * In the case of `copyout` or `reduction`, the runtime must
          write to the original variable at the end of the region.
          Those writes would violate `const`, particularly if they
          would alter known data.  In the case of `copyout`, the new
          data would likely be uninitialized values (except in the
          case of `acc exit data` as another directive might have
          initialized the variable).
    * *exp* `copy` is a subtle case.  Technically, it writes to the
      original, and `const` prevents that.  However, there are several
      arguments for why it should be permitted for a `const` variable:
        * For shared memory, it's supposed to be fine to ignore *exp*
          `copy` (or any DMA) entirely, so `const` is harmless in that
          case.
        * For discrete memory, an implementation could optimize by not
          copying back to the original variable because the value
          shouldn't change because it's `const`, so `const` is
          actually helpful here instead of problematic.
        * It should be fine to reference a `const` non-scalar within
          an `acc parallel` region even though the non-scalar is
          declared outside the region, but the `acc parallel` has
          *imp* `copy` for such a non-scalar.  Thus, *imp* `copy` must
          be permitted for the non-scalar, and so then should *exp*
          `copy`.
        * Clacc translates `copy` to OpenMP's `map` clause with a map
          type of `tofrom`, and the OpenMP implementation permits
          those for `const` variables.
    * *exp* `copyin` or *exp* `firstprivate` is fine for a `const`
      variable.  The local copy will have the original variable's
      value throughout its lifetime.
    * *exp* `present`, *exp* `no_create`, or *exp* `delete` is fine
      for a `const` variable as the initialization could have happened
      at the time of the allocation.
    * *imp* `copy` or *imp* `firstprivate` for a `const` variable
      should be fine for the same reasons as their *exp* versions.
    * *imp* `nomap` and *imp* `shared` are the only remaining *imp*
      DAs.  These don't imply any specific initialization or other
      write and so should be fine for a `const` variable.
    * `private` is *pre* for loop control variables, but they
      obviously cannot be `const` anyway, so it's a moot point.
* A `const` variable appearing in a `self` or `device` clause of an
  `update` directive is an error.  Notes:
    * It assumes the host and device copies of the variable have
      different values and one must be updated from the other, but
      doing so would violate `const`.
* It is an error to use member expressions in `firstprivate`, `private`, and
  `reduction` clauses unless the base is a C++ `this` (possibly implicit), the
  clause is not a `reduction` clause on an orphaned `loop` directive, and the
  clause is not a `private` clause on any `loop` directive.  Notes:
    * Clang currently doesn't accept member expressions in `firstprivate`,
      `private`, and `reduction` clauses in OpenMP unless the member expression
      base is a C++ `this` (possibly implicit).
    * OpenACC 3.3 requires that orphaned loop reduction variables are private.
      Within a member function, it is usually not possible to determine whether
      `this` is always private, so Clacc currently assumes it is not when
      checking this restriction.
    * In some cases, Clacc's translation of an OpenACC `private` clause on a
      `loop` construct achieves privatization by inserting a local variable
      declaration.  However, the associated implementation (which uses
      `TransformDecl` from `TreeTransform` to replace uses of the privatized
      data) currently requires a single variable declaration (`Decl*`) and thus
      cannot handle member expressions regardless of the base.
    * One possible solution for the latter issue is a temporary variable naming
      scheme to replace an entire member expression.  For example,
      `__clang_acc_tmp_<LINE>_<COL>` where `<LINE>` and `<COL>` are for the
      first reference to the member expression.
    * Another solution for the latter case might be to use an `omp scope`
      construct instead of a local variable declaration to achieve
      privatization.
* It is an error to specify subarrays with no `:` and one integer.
  Notes:
    * This notation is syntactically identical to an array subscript.
    * Indeed, OpenMP 5.0 sec. 2.1.5 appears to say that, if an array
      section has no `:` and one integer, the one integer is the start
      index and the length is one.  That's also how Clang implements
      it for OpenMP.
    * OpenACC 3.1 does not appear to specify a behavior for this
      notation.  However, in our experiments, pgcc 19.4-0 implements
      it instead as if the start index is zero and the one integer is
      the length.  On 2021/07/30 in an OpenACC Slack channel, NVIDIA
      explained that recent versions of NVHPC warn that behavior will
      eventually change: no `:` will mean the integer is an array
      subscript indicating a single element.
    * We will continue to follow the OpenACC specification, NVHPC
      behavior, and the requirements of applications to implement
      compatible support in Clacc.
* It is an error to use subarrays in `firstprivate` and `private`
  clauses.  Notes:
    * While pgcc 19.4-0 does permit subarrays in these clauses,
      OpenACC 2.7 doesn't clarify whether they're permitted, [as has
      been discussed by the OpenACC technical
      committee](https://github.com/OpenACC/openacc-spec/issues/59).
    * OpenMP 5.0 does not permit array sections in these clauses.  See
      OpenMP 5.0 sec. 2.1.5 p. 46 L10.  Thus, this feature is
      currently listed under "Potentially Unmappable Features" below.
* Behavior is undefined if a subarray specified for a variable in a
  DMA on an `acc enter data`, `acc exit data`, `acc data`, or
  `acc parallel` directive is not fully contained within any subarray
  specified for the same variable in a DMA on any enclosing `acc data`
  directive.  Notes:
    * This case does not appear to be well defined by OpenACC 3.0 or
      OpenMP 5.0, but our understanding is that it will be clarified
      in OpenMP 5.1.  For now, Clacc handles this case by deferring to
      the OpenMP implementation's handling.
* Identifying a DA as *pre* instead of *imp* only matters for combined
  directives.  Notes:
    * OpenACC 3.0 sec. 2.6 "Data Environment" says "Variables with
      predetermined data attributes may not appear in a data clause
      that conflicts with that data attribute."
        * That is, the difference between *pre* and *imp* is that a
          variable with a *pre* DA is not permitted to have a
          conflicting *exp* data clause, but a variable with an *imp*
          DA is (and then the *imp* DA is overridden).
        * DSAs are not listed in OpenACC 3.0 sec. 2.7 "Data Clauses".
          However, we assume they are also considered data clauses and
          attributes.
        * The definition of "conflicts" is not specified.  We assume a
          conflict is a different data clause or attribute for the
          same variable on the same effective directive.
    * The only *pre* DAs described by OpenACC 3.0 sec. 2.6.1
      "Variables with Predetermined Data Attributes" are:
        * *pre* `private` for locally declared variables:
            * The only *exp* DAs that could refer to them would be on
              directives nested within the scope of the variable
              declarations, and those cannot expand the visibility of
              the variables, so conflicts with *pre* `private` don't
              seem possible.
        * *pre* `private` for loop control variables:
            * On a non-combined `acc loop`, the only supported *exp*
              DAs are *exp* `private` and *exp* `reduction`, and so
              the latter is the only possible conflict with *pre*
              `private`:
                * However, as discussed under "Loop Control Variables"
                  below, Clacc does not permit *exp* `reduction` for
                  loop control variables generally.  This is true
                  whether Clacc considers the loop control variable to
                  be *pre* `private` or *imp* `shared`.  Thus, this
                  restriction is not derived from *pre*, and so, under
                  Clacc, *pre* has no significance on a non-combined
                  `acc loop`.
                * Under OpenACC 3.0, no such restriction is specified,
                  so *pre* `private` could be viewed as conflicting
                  with *exp* `reduction`.
            * On a combined directive:
                * For the same reason as on a non-combined `acc loop`,
                  the restriction against *exp* `reduction` for a loop
                  control variable is not derived from *pre* `private`
                  under Clacc.
                * All *exp* DAs other than `private` and `reduction`
                  could be viewed as conflicting with *pre* `private`
                  except that they all apply to the effective compute
                  construct while *pre* `private` applies to the
                  effective loop construct:
                    * Thus, under OpenACC 3.0, they might not be
                      viewed as conflicting.
                    * Nevertheless, Clacc views them as conflicting
                      for consistency with its handling of *exp*
                      `private` on a combined directive, as discussed
                      above.
    * In summary:
        * Under OpenACC 3.0, the only way to draw a distinction
          between *pre* and *imp* is likely the conflict between a
          *pre* `private` for a loop control variable and an *exp*
          `reduction` on either a non-combined `acc loop` or a
          combined directive.
        * Under Clacc, the only way to draw a distinction between
          *pre* and *imp* is likely the conflict between a *pre*
          `private` for a loop control variable and any *exp* data
          clause other than `private` or `reduction` on a combined
          directive.
* Additional details about data attribute support for subarrays, member
  expressions, and C++ `this` appear in `README-OpenACC-status.md`.

### Reductions ###

* If *exp* `reduction(`*o*`:`*v*`)` on an `acc loop`, and if *v* is
  gang-private, then:
    * If the loop is sequential, the reduction is trivial.
    * If the loop is gang-partitioned, the specified gang reduction is
      a trivial reduction per gang.
    * Notes:
        * This behavior is based on the second sentence of OpenACC 3.2, sec.
          2.9.11, L2099-2101:

            > If the original var is not private, this update occurs by the end
            > of the compute region, and any access to the original var is
            > undefined within the compute region.  Otherwise, the update occurs
            > at the end of the loop.

        * In the case of a trivial gang reduction, there can still be
          a non-trivial worker or vector reduction if the loop is also
          worker-partitioned or vector-partitioned.
        * A trivial reduction specifies the creation of a single private copy of
          *v* that is initialized and later merged back to the
          original *v* according *o*.  The only way that behavior
          appears to be different than just discarding the reduction
          is if either (1) the loop body performs an operation on *v*
          that's inconsistent with *o*, or (2) there's a race on
          writes to the original *v* that's somehow avoided when
          postponing the write to the exit of the loop.  Clacc makes
          the assumption that these are likely broken use cases and
          need not be supported.  Thus, Clacc implements these trivial
          reductions by simply discarding them in the translation to
          OpenMP.
* If *exp* `reduction(`*o*`:`*v*`)` on an `acc loop`, and if *v* is
  gang-shared, then *imp* `reduction(`*o*`:`*v*`)` on the parent `acc
  parallel`.  Notes:
    * Thus, Clacc handles a loop reduction for a gang-shared variable
      as a gang reduction even if the loop is not gang-partitioned and
      even if the loop is sequential.  This behavior is based on the first
      sentence from the above text quoted from the OpenACC specification.
    * Clacc interprets this gang reduction as an *imp* `reduction` on
      the `acc parallel` to facilitate the translation to OpenMP (for
      example, reductions cannot be specified on `omp distribute` but
      can be specified on `omp target teams`).
    * Outside the `acc loop`, all references to *v* within the `acc parallel`
      then refer to gang-private copies of *v*.  In this way, Clacc happens to
      support use cases not supported by the OpenACC specification: the above
      text quoted from the OpenACC specification says these references are
      undefined instead.
* It is an error if, on a particular OpenACC directive, there exist
  multiple *imp|exp* `reduction` with different reduction operators
  for a single variable *v*.  Moreover, *imp* `reduction` is included
  when applying OpenACC 3.2 sec. 2.9.11 L2112-2113.  Notes:
    * That passage specifies this restriction for *exp* `reduction` on
      nested constructs, but it doesn't discuss the case where sibling
      `acc loop` constructs specify conflicting gang reductions or
      where multiple conflicting reductions appear on the same
      directive.
* Variable type restrictions for `reduction` are specified in
  `README-OpenACC-status.md` as that is a highly user-visible issue.

### Integer Expression Arguments ###

* It is an error if an argument to `num_gangs`, `num_workers`, or
  `vector_length` is not a positive integer expression.  If the
  argument to `vector_length` is not also a constant expression, Clacc
  does not use it and reports a warning diagnostic.  See
  `README-OpenACC-status.md` for rationale.

### Loop Control Variables ###

* For an `acc loop` directive with *exp* `seq` such that the loop
  control variable is just assigned instead of declared in the init of
  the attached `for` loop, the loop control variable is *imp*
  `shared`.  Notes:
    * Otherwise, there appears to be no way to tell an aggressive
      OpenACC compiler to leave such a loop as a normal sequential
      loop in C, where the variable would normally have `shared`
      semantics in that its final value is visible after the loop.
    * OpenACC 3.0 sec. 2.6.1 L1038-1039 only requires that the
      variable is private to each thread executing the loop.  Only one
      thread executes a sequential loop, and it's the same thread that
      executes outside the loop.  The specification does not appear to
      clarify whether the variable's privacy is also limited to the
      loop's region.  Clacc uses the interpretation that, as explained
      above, seems more useful.
    * In our experiments, this choice is consistent with pgcc 19.4-0,
      but gcc 8.3.0 assumes *pre* `private` instead.
    * Clacc chooses *imp* instead of *pre* for this data attribute so
      that it can be overridden by *exp* `private`.  When the loop
      control variable is *exp* `private`, it is still private to the
      one thread executing the loop, so the *exp* `private` doesn't
      conflict with the predetermined privacy described by the spec,
      so it should be permitted according to OpenACC 3.0 sec. 2.6
      L1023-1024.
* For any other `acc loop` directive, the loop control variable is
  *pre* `private`.  Notes:
    * OpenACC 2.7 sec. 2.6.1 L876-879 only requires that the variable
      is private to each thread executing the loop.  Clacc interprets
      this as *pre* `private`, which additionally means none of those
      private variables are visible after the loop.
    * This choice is not consistent with the previous case.  However,
      because the deciding factors are the presence of *exp* `seq` and
      whether the loop control variable is declared or just assigned,
      it is straight-forward for the OpenACC programmer to determine
      the visibility of the loop control variable without, for
      example, predicting the compiler's parallelization decisions.
    * In our experiments, this choice is consistent with gcc 8.3.0.
      However, pgcc 19.4-0 appears to let each thread (within each
      gang within each worker) retain the value it would have after
      incrementing once past only the iterations it performs, so the
      value visible afterward depends on the exact partitioning and
      which thread is the master and thus continues to run after the
      loop.  Thus, pgcc seems the most consistent with the exact
      wording in the spec.
    * This choice is consistent with OpenMP 4.5's choice for
      `distribute` (`gang`) and `parallel for` (`worker`)
      (sec. 2.15.1.1 p. 179 lines 24-25).
    * This choice is not consistent with OpenMP 4.5's choice for
      `simd` (`vector`) (sec. 2.15.1.1 p. 179 lines 26-27), which
      instead specifies pre `linear`, which has `lastprivate`-like
      semantics.
    * This choice is reasonably straight-forward to translate to
      OpenMP, but the pgcc approach would be harder to translate to
      OpenMP.  For example, in our experiments, `lastprivate` produces
      either the original value from before the loop or the value
      after the entire loop and not the value after only the
      iterations performed by the thread.
    * It is not clear whether the values produced by the pgcc approach
      are actually useful given their dependence on the exact
      partitioning chosen by the compiler.
* For any `acc loop` directive, *exp* `reduction` is not permitted on
  a loop control variable regardless of its data attributes.  Notes:
    * For consistency with parallelized `acc loop` directives, this
      rule applies for sequential `acc loop` directives even
      though the mapping for them discards the `reduction`.
    * If the loop control variable is declared instead of just
      assigned in the init of the attached `for` loop, any reference
      to the variable's name in the directive's clauses refers to a
      different variable, so this rule does not apply.
    * Clang's OpenMP implementation also enforces this constraint.
      That makes sense by the OpenMP spec because an OpenMP
      `reduction` is a data sharing attribute and a loop control
      variable has a different predetermined data sharing attribute.
    * For OpenACC, gcc 7.2.0 also enforces this constraint, but pgcc
      18.4-0 does not enforce it.

### Implicit Gang Clauses ###

OpenACC 3.1 introduced a specification of *imp* `gang` clauses to
standardize a behavior of existing OpenACC implementations that is
contrary to OpenACC 3.0 and earlier.

Like an *exp* `gang` clause, an *imp* `gang` clause converts a `loop`
construct from gang-redundant mode to gang-partitioned mode.  Thus,
the exact conditions for adding *imp* `gang` clauses are important for
both performance portability and behavioral portability of OpenACC
applications.  Below is a summary of the specification plus notes on
its rationale and on Clacc's implementation:

* *imp* `gang` clauses are not yet specified for `acc kernels`
  constructs.  Notes:
    * The OpenACC technical committee hasn't yet determined an
      appropriate specification for this case.
    * Clacc doesn't yet support `acc kernels` anyway.
* Any required conversions of *exp* `auto` to *imp* `seq` on `acc
  loop` constructs and consequently dropping any `gang`, `worker`, or
  `vector` there are performed before computing *imp* `gang`
  placement.  Notes:
    * An alternative condition would be to perform *imp* `gang`
      placement first so it would not depend on the outcome of `auto`
      conversions:
        * That condition would perhaps make it marginally simpler for
          the application programmer to predict application behavior
          across implementations' varying loop analysis capabilities.
          For example, in an `acc loop auto` nest, the *imp* `gang`
          would then always be placed on the outermost loop based on
          the remaining conditions below.  Thus, the entire loop nest
          would be either gang-redundant or gang-partitioned depending
          on whether compiler is able determine that the outermost
          loop's iterations are data-independent.
        * However, in that example, consider the case when the
          outermost loop would become gang-redundant.  That is, this
          alternative condition would sometimes lead the compiler to
          place *imp* `gang` on a loop where it would be ignored when
          `auto` would later become `seq`, thus losing performance
          gains that could have been achieved by placing *imp* `gang`
          on a different loop in the same loop nest.  Performing
          `auto` conversions before computing *imp* `gang` placement
          avoids that scenario because of the rule that `gang` cannot
          be added to `seq`.
    * Currently, Clacc always converts *exp* `auto` to *imp* `seq`.
      Obviously, as Clacc grows a descriptive interpretation of
      `auto`, some such constructs will be handled as if they have
      *imp* `independent` instead.
* Within that context, an `acc loop` construct has *imp* `gang` if all
  of the following are true:
    * *not* `gang`.  Notes:
        * This just prevents ending up with *imp* `gang` and *exp*
          `gang` on the same `acc loop`.  It would be equivalent to
          remove this condition and state that the presence of both is
          the same as the presence of just one.
    * *exp* `gang` would be permitted.  Notes:
        * Based on OpenACC 3.2, *exp* `gang` would not be permitted on
          any `acc loop` construct that has (a) an ancestor `acc loop`
          construct with *exp* `gang`, *exp* `worker`, or *exp*
          `vector`, (b) *exp* `seq`, (c) a nested `acc loop` construct
          with *exp* `gang`, or (d) an enclosed call to a function to
          which an `acc routine gang` applies.
        * These restrictions are relaxed a bit for *imp* `gang`
          because `auto` conversions are performed first.  For
          example, an `acc loop auto gang` that becomes a sequential
          loop prevents a nested `acc loop` from having an *exp*
          `gang` clause but not from having an *imp* `gang` clause.
        * An implementation doesn't actually need to check whether an
          enclosing loop has *exp* `worker` or *exp* `vector`.  That
          is, if there is such an enclosing loop, then *exp* `gang` is
          either already present or permitted on some enclosing loop,
          so other conditions are sufficient to rule out adding an
          *imp* `gang` clause to the current loop.
    * There is no ancestor `acc loop` construct that is permitted to
      have *exp* `gang`.  Notes:
        * The point here is to choose the outermost construct
          possible.
        * The spec also says that an ancestor `acc loop` isn't
          relevant for this condition if there's a compute construct
          in between.  However, like most OpenACC implementations,
          Clacc currently doesn't permit a compute construct within an
          `acc loop`.
    * Notes:
        * An additional constraint of *not* `worker`, and *not*
          `vector` was considered, but it's not how existing
          implementations behave.
        * The goal of the additional constraint was to give the
          OpenACC programmer some means to specify partitioning
          exactly as he sees fit.
        * Interestingly, because we do not have this constraint, the
          only way to specify gang-redundant mode combined with
          worker-partitioned or vector-partitioned mode is via an
          orphaned loop.

### Executable Directive Placement ###

`acc update`, `acc enter data`, or `acc exit data` may not be an
immediate substatement of any other statement including another
directive but not including a labeled statement.  Notes:

* Enclosing the directive in a compound statement works around this
  restriction.
* This restriction is consistent with Clang's OpenMP support and thus
  facilitates translation to OpenMP.
* This restriction is not consistent with the OpenACC or OpenMP
  specifications:

    * OpenACC 3.0 sec. 2.14.4 "Update Directive" L2296-2298 states:

        > The update directive is executable.  It must not appear in
        > place of the statement following an if, while, do, switch,
        > or label in C or C++, or in place of the statement following
        > a logical if in Fortran.

    * There appears to be no similar restriction for other OpenACC
      executable directives, like `acc enter data` and `acc exit
      data`.
    * OpenMP 5.0 sec. 2.1.3 "Stand-Alone Directives", "Restrictions",
      p. 43 L2-3 states:

        > A stand-alone directive may not be used in place of the
        > statement following an if, while, do, switch, or label.

    * OpenMP TR8 sec. 2.1.3 "Stand-Alone Directives", "Restrictions",
      p. 41 L26-27 states:

        > A stand-alone directive may not be used in place of the
        > statement following an if, else, while, do, for, switch, or
        > a label.

    * OpenMP TR9 sec. 2.1.3 "Stand-Alone Directives", "Restrictions",
      p. 44 L25-28 states:
        * For C:

            > A stand-alone directive may not be used in place of a
            > substatement in a selection statement, in place of the
            > loop body in an iteration statement, or in place of the
            > statement that follows a label.

        * For C++:

            > A stand-alone directive may not be used in place of a
            > substatement in a selection statement or iteration
            > statement, or in place of the statement that follows a
            > label.

* This restriction is also not consistent with other OpenACC or OpenMP
  compilers:
    * pgcc 19.10-0 doesn't enforce any of these restrictions for OpenACC.
    * gcc 7.5.0 enforces them all, including the label restriction,
      for both OpenACC and OpenMP.  Moreover gcc's diagnostic
      specifically says `may only be used in compound statements`.

### `if` clause ###

* If the condition of an `update` directive's `if` clause evaluates to
  zero, the directive does not produce a runtime error for data that
  is not present on the device.  Notes:
    * OpenACC 3.0 sec. 2.14.4 "Update Directive", "Restrictions",
      L2299 states:

        > If no if_present clause appears on the directive, each var
        > in var-list must be present in the current device memory.

    * OpenMP TR9 sec. 2.13.6 "target update Construct", p. 209 L3-4
      states:

        > If a present modifier appears in the clause and the
        > corresponding list item is not present in the device data
        > environment then an error occurs and the program terminates.

    * Neither spec appears to state that this constraint is relaxed
      when an `if` condition evaluates to zero.
    * Even so, Clacc's OpenACC behavior here is the same as that of
      LLVM's current upstream OpenMP behavior and pgcc 19.10-0's
      OpenACC behavior.

Update Directives
-----------------

Clacc's current mapping of an `acc update` directive and its clauses
to OpenMP is as follows:

* `acc update` -> `omp target update`
* *exp* `if` -> *exp* `if`
* If *exp* `if_present`, then
    * *exp* `self` -> *exp* `from` without a `present` motion modifier
    * *exp* `device` -> *exp* `to` without a `present` motion modifier
* Else
    * *exp* `self` -> *exp* `from` with a `present` motion modifier
    * *exp* `device` -> *exp* `to` with a `present` motion modifier
* Notes:
    * See the discussion of the `update` directive under "OpenMP Extensions" in
      `README-OpenACC-status.md` for a description of associated diagnostics and
      for an explanation of the impact of this design on Clacc users.
    * Clacc does not currently support translating to
      `omp_target_is_present` for the same reasons as discussed for
      the `present` clause under "Data Directives" below.

Enter Data Directives
---------------------

Clacc's current mapping of an `acc enter data` directive and its
clauses to OpenMP is as follows:

* `acc enter data` -> `omp target enter data`
* *exp* `copyin` -> *exp* `map` with a `to` map type.
* *exp* `create` -> *exp* `map` with an `alloc` map type.

Exit Data Directives
--------------------

Clacc's current mapping of an `acc exit data` directive and its
clauses to OpenMP is as follows:

* `acc exit data` -> `omp target exit data`
* *exp* `copyout` -> *exp* `map` with a `from` map type.
* *exp* `delete` -> *exp* `map` with a `release` map type.

Data Directives
---------------

Clacc's current mapping of an `acc data` directive and its clauses to
OpenMP is as follows:

* `acc data` -> `omp target data`
* The translation of all data clauses listed below is affected by the
  `-fopenacc-structured-ref-count-omp=KIND` command-line option:
    * `KIND` is one of:
        * `ompx-hold` (default):
            * The `ompx_hold` map type modifier is included as
              specified below.
        * `no-ompx-hold`:
            * The `ompx_hold` map type modifier specified below is
              omitted.
    * Notes:
        * See the discussion of the `data` directive under "OpenMP Extensions"
          in `README-OpenACC-status.md` for a description of associated
          diagnostics and for an explanation of the impact of this design on
          Clacc users.
* *exp* `present` is translated according to the
  `-fopenacc-present-omp=KIND` command-line option:
    * `KIND` is one of:
        * `present` (default):
            * *exp* `present` -> *exp* `map` with a
              `present,ompx_hold,alloc` map type.
        * `no-present`:
            * *exp* `present` -> *exp* `map` with a `ompx_hold,alloc`
              map type.
    * Notes:
        * See the discussion of the `present` clause under "OpenMP Extensions"
          in `README-OpenACC-status.md` for a description of associated
          diagnostics and for an explanation of the impact of this design on
          Clacc users.
        * Clacc does not currently support translating `present` to
          calls to `omp_target_is_present` for the following reasons:
            * `omp_target_is_present` is fine for checking that data
              is present when the data is a single byte.  However, it
              does not provide a means to check a range of *N* bytes
              without requiring O(*N*) calls.  Checking for just the
              first and last bytes would be O(1), but that would not
              handle some cases where the first and last byte are part
              of multiple, separate, possibly non-contiguous
              subarrays.
            * A runtime error must be triggered when data is not
              present.  However, we are not aware of any OpenMP 5.0
              API for triggering a runtime error.  `fprintf`,
              `stderr`, and `abort` might provide an obvious
              mechanism, but that might not be how other runtime
              errors are handled by every OpenMP runtime that might be
              used by every OpenMP compiler.  Do they print to
              `stderr`, a log, or both?  Does the runtime need to be
              shut down somehow before `abort`?  Moreover, there are
              plans to introduce a runtime-error handling extension to
              the OpenACC Profiling Interface, but there's no obvious
              way for it to intercept calls to `fprintf` and `abort`.
            * Clacc would need to insert either includes of headers
              like `stdio.h` and `omp.h` or at least local
              declarations of symbols like `omp_target_is_present`,
              `omp_get_default_device`, `fprintf`, `stderr`, and
              `abort`.  Either way, such symbols could potentially
              conflict with user-defined symbols or preprocessor macro
              definitions.
            * We will reconsider adding support for such a translation
              if there is user demand, but we suspect the likelihood
              that OpenMP TR8's `present` map type modifier will be
              standardized means this option is likely not worthwhile.
* *exp* `copy` -> *exp* `map` with a `ompx_hold,tofrom` map type.
* *exp* `copyin` -> *exp* `map` with a `ompx_hold,to` map type.
* *exp* `copyout` -> *exp* `map` with a `ompx_hold,from` map type.
* *exp* `create` -> *exp* `map` with a `ompx_hold,alloc` map type.
* *exp* `no_create` is translated according to the
  `-fopenacc-no-create-omp=KIND` command-line option:
    * `KIND` is one of:
        * `ompx-no-alloc` (default):
            * *exp* `no_create` -> *exp* `map` with a
              `ompx_no_alloc,ompx_hold,alloc` map type.
        * `no-ompx-no-alloc`:
            * *exp* `no_create` -> *exp* `map` with a
              `ompx_hold,alloc` map type.
    * Notes:
        * See the translation of *imp* `nomap` on `acc parallel` for
          an additional component of the `no_create` translation.
        * See the discussion of the `no_create` clause under "OpenMP Extensions"
          in `README-OpenACC-status.md` for a description of associated
          diagnostics and for an explanation of the impact of this design on
          Clacc users.

Parallel Directives
-------------------

Clacc's current mapping of an `acc parallel` directive and its clauses
to OpenMP is as follows:

* `acc parallel` -> `omp target teams`
* *imp* `nomap` is translated as follows:
    * If the variable is *imp* `shared` on the `acc parallel`, then:
        * *imp* `nomap` -> *exp* `map` with an `alloc` map type.
        * If (1) the variable is specified as a subarray in an *exp* DMA on an
          enclosing `acc data` directive and (2) the variable has no *exp* DMA
          on any `acc data` in between, then a zero-length array section is
          specified on the variable in that map type.  There is one exception in
          the current implementation: `this[0:1]` retains its length of `1`.
        * If (1) the variable is *exp* `no_create` on an enclosing `acc data`
          directive, (2) the variable has no *exp* DMA on any `acc data` in
          between, and (3) `-fopenacc-no-create-omp=ompx-no-alloc`, then the
          `ompx_no_alloc` map type modifier is specified in the map type.
        * Under the current implementation, if the *exp* `map` in the *imp*
          `nomap` translation of at least one other variable on the same
          `acc parallel` has `ompx_no_alloc` due to the previous condition, then
          the *exp* `map` in this variable's *imp* `nomap` translation also has
          `ompx_no_alloc` even if not required.
    * Otherwise, the translations discards *imp* `nomap`.
    * Notes:
        * There is a discrepancy between the OpenACC and OpenMP
          specifications that requires careful consideration here:
            * OpenACC: For any variable, OpenACC's *imp* DAs that
              normally apply on the `acc parallel` when there's no
              *exp* DA there are suppressed by any *exp* DMA on an
              enclosing `acc data`.  In Clacc, this suppression is
              what causes a variable to be both *imp* `nomap` and
              *imp* `shared` on the `acc parallel`.
            * OpenMP: For any variable, OpenMP's *imp* DAs that
              normally apply on the `omp target teams` when there's no
              *exp* DA there are *not suppressed* by any *exp* DMA on
              an enclosing `omp target data`.
        * Thus, when a variable is both *imp* `nomap` and *imp* `shared` on the
          `acc parallel`:
            * There is an enclosing `acc data` with an *exp* DMA for the same
              variable.  Below, we call this the *suppressing DMA*.
            * Clacc's translation must override any OpenMP *imp* DAs on the
              `omp target teams` if they don't have the correct behavior for
              OpenACC, as discussed below.  In all cases, the correct behavior
              is to perform no additional action for the variable.
            * As usual (see "Explicit vs. Implicit OpenMP Clauses" above),
              Clacc's approach is to specify OpenMP *exp* DAs even if the *imp*
              DAs do not need to be overridden.
        * In the case that the suppressing DMA is `no_create`:
            * The *imp* DA specified by OpenMP 5.2 does not always achieve the
              correct behavior in this case because, when the variable is not
              present (including when it is partly present) on the device, it
              sometimes allocates the variable on the device or produces a
              runtime error.
            * To override that behavior, the Clacc translation of the *imp*
              `nomap` is an *exp* `map` with the `ompx_no_alloc,alloc` map
              type.
        * In the case that the suppressing DMA is not `no_create`:
            * The *imp* DA specified by OpenMP might achieve the correct
              behavior when the variable is not a pointer (without a subarray
              specification) or otherwise a scalar (the problems with those
              cases are discussed below), but the Clacc translation of the *imp*
              `nomap` specifies an *exp* `map` regardless.
            * The suppressing DMA guarantees the variable is already present on
              the device by the time the `acc parallel` is reached, so no new
              allocations or data transfers are possible for the variable
              regardless of the map type in the *exp* `map`.
            * The best map type to reflect a lack of new allocations and data
              transfers is probably `ompx_no_alloc,alloc`, but again many other
              map types would have the same behavior.
            * In the current implementation, so that variables can be grouped
              in a single *exp* `map` clause, it is convenient to include
              `ompx_no_alloc` when another variable on the same `acc parallel`
              actually requires `ompx_no_alloc` (suppressing DMA is
              `no_create`).  We otherwise drop `ompx_no_alloc` so that
              source-to-source mode can produce standard OpenMP.
        * In the case that the suppressing DMA specifies a subarray:
            * The *imp* DA specified by OpenMP might achieve the correct
              behavior when the suppressing DMA is not `no_create` (the problem
              with that case is discussed above), but the Clacc translation of
              the *imp* `nomap` specifies an *exp* `map` regardless.
            * That *exp* `map` specifies a zero-length array section.  This
              avoids the need to copy potentially non-constant subarray bounds
              expressions from the suppressing `no_create`.  Clang would have to
              store such a non-constant expression in a local variable and
              reference that variable in both array section specifications to
              guarantee the correct value.  This approach would be more
              complicated to implement and maintain, and the OpenMP code
              produced by source-to-source mode could be significantly more
              challenging to read.
            * Omitting the bounds is not an alternative, in particular when the
              base of the subarray is a pointer variable.  The pointer variable
              itself would be mapped instead of its target.
            * When the suppressing DMA is `no_create` and its subarray is not
              present on the device, the zero-length array section might be
              considered present if some parts of the full array are present.
              However, we assume uses of the variable in the `acc parallel` are
              unreachable when the `no_create` subarray is not present (as
              documented in `README-OpenACC-status.md`), so its mapping at run
              time should not matter.
            * When the suppressing DMA is not `no_create`, it guarantees its
              subarray is present on the device, and the zero-length array
              section is then considered present as well.
        * In the case that the variable is a pointer (without a subarray
          specification in the suppressing DMA):
            * The *imp* DAs specified by OpenMP does not achieve the correct
              behavior in this case because it handles the pointer as the base
              of an array section:
                * OpenMP 5.2 sec. 5.8.1 "Implicit Data-Mapping Attribute Rules"
                  p. 148 L29-31 specifies the *imp* `map` for the array section,
                  but OpenACC does not specify any such mapping here:

                    > A variable that is of type pointer, but is neither a
                    > pointer to function nor (for C++) a pointer to a member
                    > function, is treated as if it is the base pointer of a
                    > zero-length array section that had appeared as a list item
                    > in a map clause.

                * OpenMP 5.2 sec. 5.1.1 "Variables Referenced in a Construct"
                  p. 98 L2-4 then specifies *pre* `firstprivate` for the
                  pointer, but OpenACC requires the pointer to be `shared`:

                    > If a list item in a map clause on the target construct has
                    > a base pointer, and the base pointer is a scalar variable
                    > that does not appear in a map clause on the construct, the
                    > base pointer is firstprivate.

            * To override that behavior, the Clacc translation of the *imp*
              `nomap` is an *exp* `map` without an array section specification.
        * In the case that the variable is otherwise a scalar:
            * The normal OpenMP *imp* DA is `firstprivate`, which obviously does
              not have the `shared` behavior required by OpenACC.
            * To override that behavior, the Clacc translation of the *imp*
              `nomap` is an *exp* `map`.
        * When the variable is already present on the device, including when the
          suppressing DMA is `no_create`, the `map` clauses will
          redundantly increment and decrement the variable's dynamic
          reference counter (regardless of
          `-fopenacc-structured-ref-count-omp`) at the `acc parallel`
          entry and exit even though OpenACC specifies no manipulation
          of the variable's reference counters here.  However, this
          behavior shouldn't be observable given that it should be
          impossible to otherwise manipulate the variable's reference
          counters during the `acc parallel` region.
* All other DMAs are translated in the same manner as when appearing
  on an `acc data`.  *imp* `copy` is translated in the same manner as
  *exp* `copy`.
* The translation discards *imp* `shared`.  Notes:
    * We have not found a scenario in which *imp* `shared` -> *exp* `shared`
      would benefit behavior.  This is likely due to existing *exp* `map`
      clauses in the translation.
    * We have found many scenerios in which it's not permitted.  For example, at
      least at one time, Clang's OpenMP implementation did not permit *exp*
      `shared` for array sections or for member expressions.
    * Because it is apparently useless, it would be confusing in the OpenMP
      source generated in source-to-source mode.
* *exp*|*imp* `reduction` -> *exp* `reduction`
* *exp*|*imp* `firstprivate` -> *exp* `firstprivate`
* *exp* `private` -> *exp* `private`
* *exp* `num_gangs` -> *exp* `num_teams`
* If *exp* `num_workers` with a non-constant-expression argument, and
  if there is a nested worker-partitioned `acc loop`, then *exp*
  `num_workers` -> wrap the `omp target teams` in a compound statement
  and declare a local `const` variable with the same type and value as
  the *exp* `num_workers` argument.
* Else if *exp* `num_workers` with a non-constant-expression argument
  that potentially has side effects, then *exp* `num_workers` -> wrap
  the `omp target teams` in a compound statement and insert a
  statement that casts the argument's expression to `void`.
* Else, translation discards *exp* `num_workers`.  Notes:
    * A constant-expression argument here might be used by a nested
      worker-partitioned `acc loop`.
* If *exp* `vector_length` with a non-constant-expression argument
  that potentially has side effects, then *exp* `vector_length` ->
  wrap the `omp target teams` in a compound statement and insert a
  statement that casts the argument's expression to `void`.  Moreover,
  report a warning diagnostic that `vector_length` is being ignored.
* Else, translation discards *exp* `vector_length`.  Notes:
    * A constant expression argument here might be used by a nested
      vector-partitioned `acc loop`, but a non-constant-expression
      argument is not (this follows "Semantic Clarifications" above).

Loop Directives
---------------

Clacc does not yet support the `acc kernels` directive or an orphaned
`acc loop` directive, so an `acc loop` directive must appear in an
`acc parallel` directive.

### Sequential Loops ###

Clacc treats an `acc loop` directive as sequential if any of the
following are true:

* *exp* `seq`
* *exp* `auto`
* *not* `gang`, *not* `worker`, *not* `vector`, and not *imp* `gang`
* Notes:
    * The latter two cases normally depend on the OpenACC compiler to
      determine the best way to parallelize the loop.  Again, Clacc
      does not yet support the necessary analyses and so depends on
      the application developer to prescribe the parallelization, so
      Clacc makes the conservative choice of a sequential loop
      instead.
    * The third case (without the other two) would certainly be the
      more straightforward case to improve because OpenACC specifies
      that the loop iterations are then required to be
      data-independent (that is, *exp*|*imp* `independent`).  This is
      a case where a simple AST-level analysis could go a long way for
      existing OpenACC applications that expect a descriptive
      interpretation: Clacc could add whichever of `worker` or
      `vector` doesn't conflict with other clauses on ancestor or
      nested loops.
    * Actually, the placement of *imp* `gang` is already a step in
      this direction.  Unlike an *imp* `worker` or *imp* `vector`,
      it's necessitated due to the shift in semantics between
      gang-redundant and gang-partitioned mode.

Clacc's current mapping of a sequential `acc loop` directive and its
clauses to OpenMP is as follows:

* Translation discards the `acc loop` directive and the following
  clauses or attributes:
    * *exp* `seq`, *exp* `independent`, *exp* `auto`
    * *exp* `gang`, *exp* `worker`, *exp* `vector`
    * *exp* `collapse`
    * *pre* `private` for a loop control variable that is declared in
      the init of the attached `for` loop
    * *imp* `shared`, *exp* `reduction`
    * Notes:
        * For a loop control variable that is declared in the init of
          the attached `for` loop, a private copy is already made for
          the one thread executing the loop.
        * *imp* `shared` is only for variables referenced within the
          loop but declared outside the loop, and these are already
          shared by the simple C `for` loop.
        * *exp* `reduction` for a gang-private variable is discarded
          here because it is a trivial reduction, as discussed under
          "Semantic Clarifications" above.
        * *exp* `reduction` for a gang-shared variable is discarded
          here and is implemented instead via an *imp* `reduction` on
          the `acc parallel`, as discussed under "Semantic
          Clarifications" above.
* Otherwise, *exp*|*pre* `private` -> wrap the loop in a compound
  statement and declare an uninitialized local copy of the variable.
  Notes:
    * *exp*|*pre* `private` just needs to be local to the one thread
      executing the loop, and so creating a new local variable is
      sufficient.

A sequential `acc loop` directive is gang-redundant, worker-single,
vector-single mode.  Thus, as far as partitioning is concerned, simple
C `for` loops are sufficient.  We considered mapping instead to
various OpenMP directives so that `private` and `reduction` clauses
could simply be translated to OpenMP clauses.  To understand the
desired properties of the chosen mapping described above, it's
important to understand why each of those considered mappings would
fail to behave correctly:

* `omp parallel for num_threads(1)` does not behave as a sequential
  loop in at least two ways:
    * It makes the loop control variable *pre* `private`, but that's
      not how Clacc treats an `acc loop seq` directive's loop control
      variable that is assigned but not declared in the init of the
      attached `for` loop.
    * When the loop control variable is modified in the body of the
      loop, behavior is not defined because the init, cond, and incr
      expressions alone must determine the number of iterations.  In
      our experiments, the current Clang OpenMP implementation
      observes only those expressions and ignores even the simplest
      modification in the body.  OpenACC 2.7 sec. 2.9 L1438-1439
      describes the related OpenACC requirement, which does not apply
      in the case of `seq`, so the mapping shouldn't impose this
      restriction.
* `omp parallel num_threads(1)` (drops the `for` from the above
  directive) avoids the above problems.  However, for either mapping,
  `acc loop seq` couldn't enclose an `acc loop gang` or be nested
  within an `acc loop vector` because `omp parallel` cannot enclose an
  `omp distribute` or be nested within an `omp simd`.

### Parallelized Loops ###

If Clacc does not treat an `acc loop` directive as sequential as
described in the previous section, then it treats it as parallelized.
In that case, Clacc's current mapping of the `acc loop` directive and
its clauses to OpenMP is as follows:

* `acc loop` -> `omp`
* *exp*|*imp* `gang` -> `distribute`
* *exp* `worker` -> `parallel for`
* *exp* `vector` -> `simd`
* The output `distribute`, `parallel for`, and `simd` OpenMP directive
  components are sorted in the above order before all clauses regardless of the
  input clause order.
* If *exp* `worker`, then *exp* `num_workers` from ancestor `acc
  parallel` -> *exp* `num_threads` where the argument is either (1)
  the original *exp* `num_workers` argument if it is a constant
  expression or (2) otherwise an expression containing only a
  reference to the local `const` variable generated for that *exp*
  `num_workers`.  Notes:
    * For the ancestor `acc parallel` and for all OpenACC directives
      nested between it and this `acc loop`, Clacc leaves the OpenMP
      data sharing attribute for the local `const` variable for
      `num_workers` as implicit.  Because the variable is `const`,
      private copies are not useful, so sharing is probably most
      efficient, but not all OpenMP directives permit an *exp*
      `shared` clause.  Thus, relying on implicit data sharing
      attributes throughout simplifies the implementation.
* If *exp* `vector`, then *exp* `vector_length` with a
  constant-expression argument from ancestor `acc parallel` -> *exp*
  `simdlen`.
* `collapse` -> `collapse`
* The translation discards *imp* `shared`.  Notes:
    * We have not found a scenario in which *imp* `shared` -> *exp* `shared`
      would benefit behavior.
    * We have found many scenerios in which it's not permitted.  For example, at
      least at one time, Clang's OpenMP implementation did not permit *exp*
      `shared` on an `omp distribute` or `omp simd` directive not combined with
      an `omp parallel`, and it did not permit it for array sections or for
      member expressions.
    * Because it is apparently useless, it would be confusing in the OpenMP
      source generated in source-to-source mode.
* *pre* `private` for a loop control variable that is declared in the
  init of the attached `for` loop -> *pre* `private`.  Notes:
    * Mapping to *exp* `private` would be erroneous because it would
      refer to a variable from the enclosing scope.
* If *exp* `vector` and the loop control variable is just assigned
  instead of declared in the init of the attached `for` loop, then
  *exp*|*pre* `private` for that variable -> *pre* `linear`.  Then,
  wrap the `omp simd` in a compound statement, and declare an
  uninitialized local copy of the loop control variable.  Notes:
    * For `omp simd`, OpenMP 4.5 specifies *pre* `linear` here
      (sec. 2.15.1.1 p. 179 lines 26-27), so we cannot translate to
      *exp* `private`.
    * Clacc doesn't attempt to map to *exp* `linear` because (1) the
      OpenMP spec says the step must be the increment from the
      attached loop, (2) the OpenMP spec says the default step for an
      *exp* `linear` is 1, and (3) we don't want to have to implement
      extracting the increment from the attached loop when we can just
      rely on the behavior of *pre* `linear` and thus on Clang's or
      some other target compiler's OpenMP implementation to extract it
      for us.
* In all other cases, *exp*|*pre* `private` -> *exp* `private`.
* If *exp* `worker` or *exp* `vector`, then *exp* `reduction` -> *exp*
  `reduction`.
* Else, translation discards *exp* `reduction`.  Notes:
    * *exp* `reduction` for a gang-private variable is discarded here
      because it is a trivial gang reduction, as discussed under
      "Semantic Clarifications" above.
    * *exp* `reduction` for a gang-shared variable is discarded here
      and is implemented instead via an *imp* `reduction` on the `acc
      parallel`, as discussed under "Semantic Clarifications" above.

Combined Directives
-------------------

The only combined OpenACC directive Clacc supports so far is `acc
parallel loop`, which is translated in two stages:

* **Translate from the combined OpenACC directive to effective
  separate directives**: Clacc performs this stage during the parse
  while constructing the `acc parallel loop` directive's AST node.
  Clacc builds the effective AST subtree containing the `acc parallel`
  and `acc loop` directives, and then it records the AST subtree for
  the outermost of those directives, `acc parallel`, as a hidden
  subtree of the `acc parallel loop` node.  The associated code block
  for the `acc parallel loop` node is recorded like a normal AST child
  for each of the `acc parallel loop` node and the `acc loop` node.
* **Translate from effective separate directives to OpenMP
  directives**: This stage is performed by `TransformACCToOMP` just as
  it normally would be for the separate directives.  That is, the `acc
  parallel loop` node delegates to the `acc parallel` node.

The relationship between the `acc parallel loop` node and the `acc
parallel` node is similar to the relationship between any non-combined
OpenACC directive's node and its OpenMP node.  Moreover, it
effectively replaces that relationship.  That is, most AST traversals,
including `-ast-print`, visit the `acc parallel loop` node and skip
over the hidden subtree for its effective `acc parallel` directive
because the `acc parallel loop` node without the `acc parallel`
subtree represents the original source.  The `-ast-dump` facility
prints the `acc parallel` node as a specially marked child node, which
prints its OpenMP node as a specially marked child node.  For codegen
to LLVM IR, the `acc parallel loop` node delegates to its effective
`acc parallel` node, which delegates to its OpenMP node.

Because the second stage of translation above is delegated to the
effective `acc parallel` directive, `acc parallel loop` does not
require a mapping to OpenMP.  However, it and its clauses do require a
mapping to its effective directives for the sake of the first stage,
as follows:

* `acc parallel loop` -> `acc parallel`, whose associated code block
  is an `acc loop`, whose associated code block is the associated code
  block from the `acc parallel loop`.
* *exp* `private` -> *exp* `private` on the effective `acc loop`.
* *exp* `reduction` -> *exp* `reduction` on the effective `acc loop`.
* Each remaining explicit clause is permitted on only one of the
  separate OpenACC directives, and so it is mapped to that directive.
* Predetermined and implicit attributes do not require a mapping to
  the effective directives because there are none because semantic
  analysis computes them only on the effective directives.

Atomic Directive
----------------

Clacc's current mapping of an `acc atomic` directive and its clauses to OpenMP
is as follows:

* `acc atomic` -> `omp atomic`
* *exp* `read` -> *exp* `read`
* *exp* `write` -> *exp* `write`
* *exp*|*imp* `update` -> *exp* `update`
* *exp* `capture` -> *exp* `capture`
* *exp* `compare` -> *exp* `compare`.  Note: This is an OpenACC extension.

Routine Directive
-----------------

Clacc's current mapping of an `acc routine` directive and its clauses
to OpenMP is as follows:

* When appearing in a function definition at the statement level (as opposed to,
  for example, appearing at the member-list level of a type definition within
  that function definition), the translation discards *exp* `acc routine`.
  Notes:
    * Clang currently does not support *exp* `omp declare target` in a function
      definition at the statement level, so there appears to be no other choice.
    * Let *f* be the function in whose definition the `acc routine` directive
      appears, and let *g* be the function to which the `acc routine` directive
      applies.  There are three purposes an *exp* `omp declare target` might
      have served:
        * For readability in source-to-source mode.  That is, the OpenMP source
          would more closely match the OpenACC source.
        * For a use of *g* in a compute region that is in the scope of the
          `acc routine` directive.  Fortunately, a use of *g* in a compute
          region already produces an *imp* `omp declare target`, so the *exp*
          `omp declare target` is not actually needed for this purpose.
        * For a definition of *g* in the scope of the `acc routine` directive.
          Unfortunately, this case is addressed only when a compute region use
          of *g* produces an *imp* `omp declare target`.  Even then, that *imp*
          `omp declare target` is sometimes not visible at the definition of *g*
          due to obscure issues in Clang's handling of multiple declarations of
          a function.  However, because Clacc does not yet support C++ lambdas
          or the nested function definition extension for C, the definition of
          *g* is necessarily outside *f*, so this purpose falls under the caveat
          documented in `README-OpenACC-status.md` about the limited visibility
          of an `acc routine` directive.
* Elsewhere:
    * *exp* `acc routine` -> `omp declare target` plus an
      `omp end declare target` following the associated function declaration.
    * The translation discards *exp* `gang`|`worker`|`vector`|`seq`.
      Notes:
        * These clauses appear to have no counterpart in OpenMP.
        * OpenACC uses them to verify compatibility of a function with its uses.
* The translation discards *imp* `acc routine seq`.  Notes:
    * OpenACC and OpenMP rules for implicitly determining that a
      function must be compiled for offload appear to be compatible (basically,
      the function is used in offload code), so it seems unnecessary to
      translate *imp* `acc routine seq` to OpenMP.
    * Translating *imp* `acc routine seq` to OpenMP would sometimes
      require seriously cluttering the application source.  Moreover,
      it is not clear how to handle a function, such as `printf`, used
      in the application's offload code but declared in a header file,
      which is potentially from a different code base.
    * Even so, *imp* `acc routine seq` is computed as it can be useful
      in OpenACC analyses and diagnostics.  For example, it can be
      used to check compatible levels of parallelism between caller
      and callee.

In the Clang AST, a single `OMPDeclareTargetDeclAttr` represents an
`omp declare target` and `omp end declare target` pair.

Potentially Unmappable Features
-------------------------------

It might prove to be impossible to map some OpenACC features to
standard OpenMP.  For such features, our plan is to map to OpenMP
language or runtime extensions, which we will implement as necessary.

When source-to-source translation (as opposed to normal full
compilation) is enabled, we will implement diagnostics to identify
uses of such features unless those diagnostics are inexact and prove
to have too many false positives.  In the worst cases, we would
identify such features at run time.

The following is a list of OpenACC features we have identified that
might not be possible to map to OpenMP, but we are still investigating
possible solutions:

* `vector_length` with a non-constant-expression argument because
  `simdlen`, to which `vector_length` is translated, requires a
  constant expression.  In the future, Clacc might support alternative
  mappings for partitioning types, either configured by the user or
  computed automatically.  If `acc loop vector` were mapped to `omp
  parallel for`, `vector_length` with a non-constant-expression
  argument would be possible.
* Orphaned `acc loop` directive that observes `num_workers` and
  `vector_length` because the enclosing compute construct from which
  those clauses would normally be applied during translation is not
  statically visible.
* Subarrays specifying non-contiguous blocks in dynamic
  multidimensional arrays because these cannot be mapped to OpenMP
  array sections.  Notes:
    * OpenACC 2.7 sec. 2.7.1 L1108-1109 permits such subarrays.
    * OpenMP 5.0 sec. 2.9.7.1 p. 322 L3 does not permit such array
      sections in `map` clauses.
* Non-constant integer expressions in subarrays on gang-shared
  variables in `reduction` clauses on `acc loop` constructs because
  those clauses must be copied to the parent `acc parallel` (or rather
  the `omp target teams`) but the expressions might evaluate to
  different values there.
* Subarrays in `firstprivate` and `private` clauses because OpenMP
  does not permit array sections in those clauses.  See "Semantic
  Clarifications" above for details.
* Multiple reference counters because OpenMP has just one reference
  counter.

C++ Issues
----------

* Restrictions for private and reduction clauses related to
  const-qualified types could be relaxed in the case of mutable
  fields.  The OpenMP implementation does this, as hinted by OpenMP
  5.0 sec. 2.19.1.1 phrase "with no mutable members".

OpenACC Runtime
===============

Clacc's OpenACC runtime is designed as a layer on top of Clacc's
version of LLVM's OpenMP runtime.  It is built as the library
`libacc2omp.so`.

Support for the OpenACC Runtime Library API appears primarily in the
source file `openmp/libacc2omp/src/api.cpp`.  Clacc's mapping to the
OpenMP Runtime Library Routines can be found there along with notes on
relevant ambiguities in the OpenACC and OpenMP specifications.  A
briefer set of notes tailored more for users can be found in the
section "OpenACC Runtime Library API and Preprocessor" in
`README-OpenACC-status.md`.  The mapping relies on the following
OpenMP extensions, which are implemented in Clacc's version of LLVM's
OpenMP runtime library:

* `omp_device_t`
* `omp_device_t omp_get_device_type(int device_num);`
* `int omp_get_num_devices_of_type(omp_device_t device_type);`
* `int omp_get_typed_device_num(int device_num);`
* `int omp_get_device_of_type(omp_device_t device_type, int typed_device_num);`
* `size_t omp_get_accessible_buffer(const void *ptr, size_t size, int device_num, void **buffer_host, void **buffer_device);`
* `void *omp_target_map_to(void *ptr, size_t size, int device_num);`
* `void *omp_target_map_alloc(void *ptr, size_t size, int device_num);`
* `void omp_target_map_from(void *ptr, size_t size, int device_num);`
* `void omp_target_map_from_delete(void *ptr, size_t size, int device_num);`
* `void omp_target_map_release(void *ptr, size_t size, int device_num);`
* `void omp_target_map_delete(void *ptr, size_t size, int device_num);`
* `void omp_target_update_to(void *ptr, size_t size, int device_num);`
* `void omp_target_update_from(void *ptr, size_t size, int device_num);`
* `void *omp_get_mapped_hostptr(const void *ptr, int device_num);`

`acc_on_device` is unique in that OpenACC requires it to compile to a
constant when its argument is constant.  Its implementation appears
fully within Clacc's `openacc.h`, whose source file is
`openmp/libacc2omp/src/include/openacc.h.var`.  Documentation of that
implementation and its reliance on OpenMP extensions appears in
comments there.  Notes on relevant ambiguities in the OpenACC
specification and Clacc's OpenACC extensions appear within section
"OpenACC Runtime Library API and Preprocessor" in
`README-OpenACC-status.md`.

Support for the OpenACC Profiling Interface appears primarily in the
source file `openmp/libacc2omp/src/prof.cpp`.  It is documented in the
next section, including Clacc's mapping to OMPT and required OMPT
extensions.  It also relies on some of the OpenMP extensions listed
above.

Further details on how Clacc's OpenACC runtime might one day interact
with OpenMP runtimes from other OpenMP implementations can currently
be found in the comments in the source files `acc2omp-handlers.h.var`
and `acc2omp-backend.h.var` in `openmp/libacc2omp/src/include`.

OpenACC Profiling Interface
===========================

Clacc's support for the OpenACC Profiling Interface is currently an
early prototype.  It is designed as a wrapper around OpenMP's OMPT.
Currently, it has been tested with an extended version of LLVM's
implementation of OMPT.

Background
----------

The OpenACC Profiling Interface is an interface between an OpenACC
runtime and an OpenACC profiling library that can be used to profile
an OpenACC application.  An OpenACC implementation, such as Clacc, is
responsible for providing the OpenACC compiler and the OpenACC
runtime.  The user of that implementation is responsible for providing
the OpenACC profiling library and the OpenACC application.

The user compiles his OpenACC application using the OpenACC compiler.
However, he can use any standard compiler to compile his OpenACC
profiling library as it is not intended to employ OpenACC directives.
The user then links his compiled OpenACC application, his compiled
OpenACC profiling library, and the provided OpenACC runtime.  This
linking step might be static or dynamic, and it might be replaced with
dynamic loading.  For simplicity in this document, we always refer to
this step as linking.

The OpenACC Profiling Interface defines OpenACC event types,
signatures for callback functions to respond to those event types, and
a callback registration interface.  The user's OpenACC profiling
library is responsible for implementing such callback functions and
registering them for relevant event types.  The OpenACC runtime is
responsible for receiving these registrations and, when an OpenACC
event type occurs during the OpenACC application's execution, calling
the registered callback function and passing the profiling data
required by its function signature.

See chapter 5 "Profiling Interface" of OpenACC 2.7 for further
details.

OMPT is similar to the OpenACC Profiling Interface such that the
analogues of an OpenACC runtime, OpenACC profiling library, and
OpenACC application are an OpenMP runtime, OMPT tool, and OpenMP
application.  See chapter 4 "OMPT Interface" of OpenMP 5.0 for further
details.

Objectives
----------

There are several profiling use cases that might come to mind when
considering that the Clacc compiler translates OpenACC to OpenMP.
It's important to be clear about which use cases Clacc supports.  In
short, Clacc enables OpenACC applications to be profiled using either
OpenACC profiling libraries or OMPT tools.  The rest of this section
explains the importance of these use cases and how, at a high level,
Clacc enables them.  The remaining sections focus on Clacc's support
for OpenACC profiling libraries.

A traditional OpenACC runtime, such as the runtime provided by PGI, is
not useful when an OpenACC application is compiled by the Clacc
compiler.  The reason is that the Clacc compiler, whether in
traditional mode or source-to-source mode, always translates OpenACC
applications to OpenMP.  Thus, an OpenMP runtime instead is required
to execute the application.  This requirement is a deliberate part of
Clacc's strategy to reuse rather than duplicate the capabilities of
OpenMP implementations, in particular the one provided by Clang and
LLVM.

To profile an OpenACC application using an OMPT tool, Clacc's OpenACC
Profiling Interface support is irrelevant.  That is, because the Clacc
compiler translates OpenACC directives to OpenMP, compilation with the
Clacc compiler is sufficient to enable profiling an OpenACC
application using an OMPT tool.  This use case may be worthwhile for
taking advantage of existing OMPT tools, for users desiring to analyze
how their OpenACC application interacts with an OpenMP runtime, and
for users desiring to migrate an application from OpenACC to OpenMP.
However, this use case is not helpful for taking advantage of existing
OpenACC profiling libraries.  Moreover, being forced to work with or
develop OMPT tools instead of OpenACC profiling libraries may be
confusing for OpenACC developers.

Clacc's OpenACC Profiling Interface support is designed to enable any
OpenACC profiling library to profile any OpenACC application
specifically when the latter is compiled by the Clacc compiler.
Again, an OpenMP runtime is required to execute the application in
this case, so Clacc's OpenACC Profiling Interface support is designed
as a wrapper around the OMPT support provided by OpenMP runtimes.
This design follows the aforementioned strategy to reuse rather than
duplicate the capabilities of OpenMP implementations.

In theory, this design does not require the original application to be
OpenACC.  That is, Clacc's OpenACC Profiling Interface support should
also enable any OpenACC profiling library to profile any OpenMP
application.  However, this is not a use case we are currently
investigating.  Moreover, our estimation at this point is that the
OpenACC Profiling Interface lacks many features desirable for
profiling OpenMP applications.

Clacc offers no support for translating OpenACC profiling libraries
into OMPT tools at the level of their source code.  That is, the Clacc
compiler translates OpenACC directives within OpenACC applications,
but it does not process any part of the OpenACC Profiling Interface
within OpenACC profiling libraries, which are not written using
directives.

Design
------

Clacc's OpenACC Profiling Interface support is designed to enable
OpenACC profiling libraries to profile OpenACC applications compiled
by the Clacc compiler in the following manner:

* The user compiles his OpenACC application to binary form using
  either (1) the Clacc compiler in traditional compilation mode or (2)
  the Clacc compiler in source-to-source mode followed by compilation
  to binary form using any OpenMP compiler.
* The user compiles his OpenACC profiling library to binary form using
  any standard compiler.  The Clacc compiler can be used if desired
  here but is not required as no OpenACC directives should be
  involved.
* The user links together his compiled OpenACC application, his
  compiled OpenACC profiling library, an OpenMP runtime that
  implements the OMPT interface, and Clacc's OpenACC runtime.
* At run time, Clacc's OpenACC runtime receives OpenACC callback
  registrations for OpenACC events from the user's OpenACC profiling
  library.  It then registers the necessary OMPT callbacks for related
  OMPT events with the OpenMP runtime.
* OMPT callback functions that Clacc's OpenACC runtime registers are
  implemented within Clacc's OpenACC runtime.  These functions
  translate the profiling data they receive into the profiling data
  required for OpenACC callbacks.  They then call the required OpenACC
  callback functions.

This design should enable Clacc's OpenACC Profiling Interface support
to be implemented entirely in Clacc's OpenACC runtime as a wrapper
around OMPT with no custom support required from the OpenACC or OpenMP
compiler.  However, as discussed in the next section, due to OMPT
limitations, Clacc does not yet fully realize the design as described
above, and some compiler support is required for some use cases.

### OMPT Extensions ###

In order for Clacc to fully realize the design described in the
previous section for supporting the OpenACC Profiling Interface
specified by OpenACC 2.7, the specification of OMPT would have to be
extended beyond OpenMP 5.0.  The problem is that some OpenACC
Profiling Interface events do not correspond to any OMPT events, and
some OpenACC Profiling Interface profiling data cannot be obtained via
OMPT callbacks.  These limitations cause Clacc's support to fall short
of its intended design in two ways:

* Clacc's OpenACC runtime requires OMPT extensions that are currently
  supported only in Clacc's version of LLVM's OpenMP runtime.  Thus,
  other OpenMP runtimes cannot be used.
* Some OpenACC profiling data that is available when the user compiles
  his OpenACC application using the Clacc compiler's traditional
  compilation mode is not available or can be inaccurate when using
  source-to-source mode followed by a foreign OpenMP compiler.  The
  reason is that this profiling data is made available via extensions
  to the LLVM IR codegen phase for OpenMP in Clacc's version of Clang.

These OMPT limitations, OMPT extensions, and Clang extensions are
described in the sections "OpenACC to OpenMP Mapping: Events" and
"OpenACC to OpenMP Mapping: Profiling Data".

Furthermore, upstream LLVM's OpenMP runtime support for OMPT is
currently incomplete, specifically omitting components related to
device offloading, which are the focus of the OpenACC Profiling
Interface.  Of the OMPT callbacks that are required by Clacc, there is
only one that is currently implemented in the upstream LLVM OpenMP
runtime: the `finalize` callback set by `ompt_start_tool`.  For Clacc,
we have prototyped support for all other required OMPT callbacks,
which are listed in the next section.  These extensions are in a very
early stage of development and are not ready to be submitted to
upstream LLVM.  In some cases, we have taken short cuts that may make
sense only in the context of Clacc.

In summary, Clacc's OpenACC Profiling Interface support currently
depends on extensions to OMPT, to upstream LLVM's OpenMP runtime, and
to Clang's LLVM IR codegen for OpenMP.  In the future, if the OMPT
extensions are included in the OpenMP specification, and if OpenMP
compilers fully implement the specification, Clacc will be able to
fully realize the design described in the previous section.

### OpenACC to OpenMP Mapping: Events ###

The following table shows, for each OpenACC event for which an OpenACC
profiling library registers a callback, the OMPT callbacks that are
registered by Clacc's OpenACC Profiling Interface support.

| OpenACC Event                     | OMPT Callback                                                                                                           |
|:----------------------------------|:------------------------------------------------------------------------------------------------------------------------|
| `acc_ev_device_init_start`        | **`ompt_callback_device_initialize_start`**                                                                             |
| `acc_ev_device_init_end`          | `ompt_callback_device_initialize`                                                                                       |
| `acc_ev_device_shutdown_start`    | **`ompt_callback_device_finalize_start`**                                                                               |
| `acc_ev_device_shutdown_end`      | `ompt_callback_device_finalize`                                                                                         |
| `acc_ev_runtime_shutdown`         | `finalize` set by `ompt_start_tool`                                                                                     |
| `acc_ev_create`                   | `ompt_callback_target_data_op_emi(optype=ompt_target_data_associate, endpoint=ompt_scope_beginend)`                     |
| `acc_ev_delete`                   | `ompt_callback_target_data_op_emi(optype=ompt_target_data_disassociate, endpoint=ompt_scope_beginend)`                  |
| `acc_ev_alloc`                    | `ompt_callback_target_data_op_emi(optype=ompt_target_data_alloc, endpoint=ompt_scope_end)`                              |
| `acc_ev_free`                     | `ompt_callback_target_data_op_emi(optype=ompt_target_data_delete, endpoint=ompt_scope_begin)`                           |
| `acc_ev_enter_data_start`         | `ompt_callback_target_emi(kind=ompt_target_enter_data|`**`ompt_target_region_enter_data`**`, endpoint=ompt_scope_begin)`|
| `acc_ev_enter_data_end`           | `ompt_callback_target_emi(kind=ompt_target_enter_data|`**`ompt_target_region_enter_data`**`, endpoint=ompt_scope_end)`  |
| `acc_ev_exit_data_start`          | `ompt_callback_target_emi(kind=ompt_target_exit_data|`**`ompt_target_region_exit_data`**`, endpoint=ompt_scope_begin)`  |
| `acc_ev_exit_data_end`            | `ompt_callback_target_emi(kind=ompt_target_exit_data|`**`ompt_target_region_exit_data`**`, endpoint=ompt_scope_end)`    |
| `acc_ev_update_start`             | `ompt_callback_target_emi(kind=ompt_target_update, endpoint=ompt_scope_begin)`                                          |
| `acc_ev_update_end`               | `ompt_callback_target_emi(kind=ompt_target_update, endpoint=ompt_scope_end)`                                            |
| `acc_ev_compute_construct_start`  | `ompt_callback_target_emi(kind=ompt_target, endpoint=ompt_scope_begin)`                                                 |
| `acc_ev_compute_construct_end`    | `ompt_callback_target_emi(kind=ompt_target, endpoint=ompt_scope_end)`                                                   |
| `acc_ev_enqueue_launch_start`     | `ompt_callback_target_submit_emi(endpoint=ompt_scope_begin)`                                                            |
| `acc_ev_enqueue_launch_end`       | `ompt_callback_target_submit_emi(endpoint=ompt_scope_end)`                                                              |
| `acc_ev_enqueue_upload_start`     | `ompt_callback_target_data_op_emi(optype=ompt_target_data_transfer_to_device, endpoint=ompt_scope_begin)`               |
| `acc_ev_enqueue_upload_end`       | `ompt_callback_target_data_op_emi(optype=ompt_target_data_transfer_to_device, endpoint=ompt_scope_end)`                 |
| `acc_ev_enqueue_download_start`   | `ompt_callback_target_data_op_emi(optype=ompt_target_data_transfer_from_device, endpoint=ompt_scope_begin)`             |
| `acc_ev_enqueue_download_end`     | `ompt_callback_target_data_op_emi(optype=ompt_target_data_transfer_from_device, endpoint=ompt_scope_end)`               |
| `acc_ev_wait_start`               | *unimplemented*                                                                                                         |
| `acc_ev_wait_end`                 | *unimplemented*                                                                                                         |

This mapping is expected to be sufficient only for the OpenACC
directives and clauses currently supported by the Clacc compiler, and
so some OpenACC events are not yet implemented, as indicated in the
table.

Sometimes, for an OMPT callback to serve the role specified in the
above table, the data passed to the callback must meet certain
conditions.  Those conditions, if any, are shown in parentheses next
to the callback name in the table.

OMPT callbacks that we devised for Clacc's OpenACC Profiling Interface
support and that are not specified by OpenMP 5.1 are shown in
**bold**.

Because an OpenACC profiling library can register and unregister
callbacks for OpenACC events throughout its execution, and because
some OMPT callbacks are used for multiple OpenACC events, Clacc
maintains a reference count for each OMPT callback to determine when
it is safe to unregister it from the OpenMP runtime.

### OMPT Callback Timing vs. Extensions ###

In some cases, the precise timing required for an OMPT event relative
to a set of related OpenMP runtime actions was not immediately obvious
to us when reading the OpenMP 5.0 or 5.1 specification.  This timing
is particularly important when such a set corresponds to multiple
OpenACC events but to only one OMPT event.  In that case, identifying
that timing is key to identifying what OpenACC event the OMPT event's
callback should trigger and what OMPT extension events are needed to
trigger the remaining OpenACC events.  The following list explains
Clacc's rationale for such cases:

* `ompt_callback_device_initialize`
    * OpenMP 5.0 sec. 2.12.1 p. 160 L3-7:

        > The device-initialize event occurs in a thread that
        > encounters the first target, target data, or target enter
        > data construct or a device memory routine that is associated
        > with a particular target device after the thread initiates
        > initialization of OpenMP on the device and the device's
        > OpenMP initialization, which may include device-side tool
        > initialization, completes.

    * OpenMP 5.0 sec. 4.5.2.19 p. 482 L24-25:

         > The OpenMP implementation invokes this callback after
         > OpenMP is initialized for the device but before execution
         > of any OpenMP construct is started on the device.

    * While the first passage above is hard to parse, combined with
      the second passage, it seems clear that this callback triggers
      after device initialization is complete.
    * Clacc's implementation of this callback thus triggers
      `acc_ev_device_init_end` instead of `acc_ev_device_init_start`.

* `ompt_callback_device_finalize`
    * OpenMP 5.1, sec. 2.14.1, "Device Initialization", p. 186,
      L12-13:

        > The device-finalize event for a target device that has been
        > initialized occurs in some thread before an OpenMP
        > implementation shuts down.

    * OpenMP 5.1 sec. 4.5.2.20, "ompt_callback_device_finalize_t",
      p. 531, L27-33:

        > A registered callback with type signature
        > ompt_callback_device_finalize_t is dispatched for a device
        > immediately prior to finalizing the device.  Prior to
        > dispatching a finalization callback for a device on which
        > tracing is active, the OpenMP implementation stops tracing
        > on the device and synchronously flushes all trace records
        > for the device that have not yet been reported. These trace
        > records are flushed through one or more buffer completion
        > callbacks with type signature
        > ompt_callback_buffer_complete_t as needed prior to the
        > dispatch of the callback with type signature
        > ompt_callback_device_finalize_t.

    * The second passage above says flushing of traces occurs "prior
      to dispatching a finalization callback", which occurs
      "immediately prior to finalizing the device".  This might imply
      that flushing of traces is prior to and not part of the
      finalization process.  Clacc assumes instead that "finalizing
      the device" really indicates the *end* of the finalization
      process, which can then be considered to include flushing of
      traces.
    * Clacc's implementation of this callback thus triggers
      `acc_ev_device_shutdown_end` instead of
      `acc_ev_device_shutdown_start`, which is logically triggered
      before flushing of traces.  (However, device traces haven't yet
      actually been implemented in LLVM's OpenMP runtime.)

* `ompt_callback_target_data_op_emi(optype=ompt_target_data_alloc)`
    * OpenMP 5.1, sec. 2.21.7.1 "map Clause", p. 353, L6-7:

        > The target-data-op-begin event occurs before a thread
        > initiates a data operation on a target device.  The
        > target-data-op-end event occurs after a thread initiates a
        > data operation on a target device.

    * OpenMP 5.1, sec. 3.8.1 "omp_target_alloc", p. 413, L14-15:

        > The target-data-allocation-begin event occurs before a
        > thread initiates a data allocation on a target device.  The
        > target-data-allocation-end event occurs after a thread
        > initiates a data allocation on a target device.

    * OpenMP 5.1, sec. 4.5.2.25 "ompt_callback_target_data_op_emi_t
      and ompt_callback_target_data_op_t", p. 537, L11:

        > The dest_addr argument indicates the data address after the
        > operation.

    * Clacc assumes `dest_addr` is the address of the allocation on
      the device.  However, it's unclear how any information from
      after the allocation can be obtained if the callbacks are
      dispatched upon initiation of the allocation.  This point seems
      undeniable in the case of *target-data-allocation-begin*, but it
      is less clear for *target-data-allocation-end*.
    * Clacc assumes *target-data-allocation-end* should actually occur
      after the destination/device address is known, so Clacc
      dispatches the associated `ompt_scope_end` callback after the
      allocation has completed in order to pass it to the callback for
      `acc_ev_alloc`.

* `ompt_callback_target_data_op_emi(optype=ompt_target_data_delete)`
    * OpenMP 5.1, sec. 2.21.7.1 "map Clause", p. 353, L6-7:

        > The target-data-op-begin event occurs before a thread
        > initiates a data operation on a target device.  The
        > target-data-op-end event occurs after a thread initiates a
        > data operation on a target device.

    * OpenMP 5.1, sec. 3.8.2 "omp_target_free", p. 415, L11-12:

        > The target-data-free-begin event occurs before a thread
        > initiates a data free on a target device.  The
        > target-data-free-end event occurs after a thread initiates a
        > data free on a target device.

    * OpenMP 5.1, sec. 4.5.2.25 "ompt_callback_target_data_op_emi_t
      and ompt_callback_target_data_op_t", p. 537, L11:

        > The dest_addr argument indicates the data address after the
        > operation.

    * To the callback for `acc_ev_free`, Clacc passes the `dest_addr`
      from the `ompt_scope_begin` callback instead of the
      `ompt_scope_end` callback so that the device allocation is still
      valid.

### OpenACC to OpenMP Mapping: Profiling Data ###

This section describes how, for profiling data required for OpenACC
callbacks, Clacc arranges to obtain that data from OMPT callbacks.
For now, this section does not cover all profiling data.  [TODO: That
might be helpful.]  Instead, this section focuses on OpenACC profiling
data that depends on OMPT extensions and Clacc compiler extensions.

For now, the only profiling data that Clacc supports and that requires
extensions beyond the new OMPT callbacks discussed in section "OpenACC
to OpenMP Mapping: Events" are:

* The `parent_construct` and `implicit` fields common to all members
  of the `acc_event_info` union.
* The `acc_prof_info` structure's source location information.
* The `acc_data_event_info` structure's `var_name` field.

In the remainder of this section, we explain these extensions.  As
Clacc grows support for additional profiling data, we expect Clacc
will reuse these or similar extensions.

Clacc's version of the LLVM OpenMP runtime extends OpenMP 5.0
sec. 4.6.1 "Entry Points in the OMPT Callback Interface" with two new
entry points, `ompt_get_trigger_info` and `ompt_get_data_expression`.
The type signatures of these entry points are
`ompt_get_trigger_info_t` and `ompt_get_data_expression_t`, as
follows:

```
// TODO: The members listed below are those currently needed for
// Clacc, but obviously there are more directives in OpenMP that should
// have members here.  A specific value for each member can be specified
// later (perhaps during standardization) for the sake of backward
// compatibility guarantees.
typedef enum ompt_trigger_kind_t {
  ompt_trigger_unknown = 0,
  ompt_trigger_target_update,
  ompt_trigger_target_enter_data,
  ompt_trigger_target_exit_data,
  ompt_trigger_target_data,
  ompt_trigger_target_teams,
  ompt_trigger_runtime_api,
} ompt_trigger_kind_t;

// All fields are designed so that null-initialization is a reasonable
// default indicating no trigger information.
typedef struct ompt_trigger_info_t {
  ompt_trigger_kind_t kind;
  int is_explicit_event;
  const char *src_file;
  const char *func_name;
  int line_no;
  int end_line_no;
  int func_line_no;
  int func_end_line_no;
} ompt_trigger_info_t;

typedef ompt_trigger_info_t *(*ompt_get_trigger_info_t) (void);

typedef const char *(*ompt_get_data_expression_t) (void);
```

These entry points can be called from OMPT callback functions.
`ompt_get_trigger_info` returns an `ompt_trigger_info_t` with
information about the directive or OpenMP runtime library routine that
triggered the callback, and `ompt_trigger_info_t` is designed so that
null-initialization of all fields logically indicates the case when
the callback is not associated with a directive or runtime library
routine.  If the callback is `ompt_callback_target_data_op` or
`ompt_callback_target_data_op_emi`, `ompt_get_data_expression` returns
an expression identifying the data on which the operation associated
with the callback is performed, and it otherwise returns `NULL`.
Often the expression is just a variable name, but it can also include
a more complex expression, such as an array section, if specified in
an explicit `map` clause.

The OMPT callback functions that Clacc's OpenACC runtime implements
call these entry points to retrieve information to pass to OpenACC
callbacks.  OpenACC's `parent_construct` and `implicit` fields are
computed from the `kind` and `is_explicit_event` fields of the
`ompt_trigger_info_t` returned by `ompt_get_trigger_info`, and source
location information is taken directly from the remaining fields.
OpenACC's `var_name` field is taken directly from the expression
returned by `ompt_get_data_expression`.

In the case of OpenMP directives, upstream Clang's LLVM IR codegen
phase currently makes the information required for
`ompt_get_trigger_info` and `ompt_get_data_expression` available to
the OpenMP runtime only if debug information is enabled with Clang
command-line options like `-gline-tables-only` or `-g`.  Clacc does
not alter this behavior except for OpenMP directives that were
translated from OpenACC directives in traditional compilation mode.
In that case, Clacc adjusts Clang's LLVM IR codegen phase to make that
information available to the OpenMP runtime regardless of such
command-line options.

So far, OpenACC directives can be identified uniquely by the OpenMP
directives to which the Clacc compiler translates them.  However, the
same is not true for OpenACC Runtime Library routines and the OpenMP
Runtime Library routines they call.  For this reason, Clacc's version
of the LLVM OpenMP runtime also extends OpenMP 5.1 sec. 3 with two new
routines:

```
void omp_set_source_info(const char *src_file, const char *func_name,
                         int line_no, int end_line_no, int func_line_no,
                         int func_end_line_no);
void omp_clear_source_info();
```

Clacc implements each OpenACC routine to call these routines around
its OpenMP routine calls to override the source info recorded by the
latter for use by `ompt_get_trigger_info`.  In this case, all fields
it passes to `omp_set_source_info` are null except `func_name`, which
indicates the OpenACC routine.  That is, Clacc's implementation does
not attempt to climb the call stack to determine the caller of the
OpenACC routine, and source files and line numbers within the OpenACC
routine implementation are not expected to be useful for an OpenACC
application developer.  Even so, Clacc defines `omp_set_source_info`
to accept the remaining source information fields as well to make it
more appealing as a general feature that can be used by OpenMP
applications.  Clacc uses the `omp_` prefix instead of `ompt_` as
these routines seem like they might be useful for other purposes
outside OMPT, such as debugging facilities, in the future.

When using Clacc's compiler in source-to-source mode followed by a
foreign OpenMP compiler, we expect that the foreign OpenMP runtime's
entry point lookup function would simply return null for such
non-standard entry points.  In that case, Clacc's OpenACC runtime
passes values indicating no directive information and no data
expression to the OpenACC callbacks (see the "Limitations" section
below for details).  Of course, if these entry points are one day
standardized, they will then be the responsibility of the foreign
OpenMP compiler to provide the required information to its OpenMP
runtime, which would then expose it via these entry points, just as
Clacc's compiler and OpenMP runtime do now.  At that point, this
information will be available to OpenACC profiling libraries
regardless of which Clacc compiler mode the user uses to compile his
OpenACC application.

As an alternative to the above OMPT and LLVM IR codegen extensions, we
also considered a source-level design.  That is, we considered
extending the Clacc compiler's `TransformACCToOMP` component to insert
source-level calls to pass the required information directly to
Clacc's OpenACC runtime.  With that approach, the information would be
available today even if the user compiled his OpenACC application
using source-to-source mode followed by a foreign OpenMP compiler
targeting a foreign OpenMP runtime, which would then not need to
provide support for the entry points.  However, that approach has
several issues.  First, the Clacc OpenACC runtime calls would be
separate from the OpenMP runtime calls for the associated OpenMP
directives, and thus they might interfere with optimizations,
especially in foreign OpenMP compilers that would see them as opaque
function calls.  Second, the Clacc compiler's source-to-source mode is
intended to produce standard OpenMP that can be compiled by foreign
OpenMP compilers, but these runtime calls are not standard and would
fail to link without Clacc's OpenACC runtime even when support for
OpenACC profiling and routines is not desired.  Third, unlike LLVM IR
codegen, `TransformACCToOMP` currently runs immediately after each
OpenACC directive is parsed, when `func_end_line_no` is not yet known.
There are various ways to mitigate some of these issues, such as
requiring the user to opt into these source-level insertions when
OpenACC profiling is required.  However, it is our conclusion that
Clacc's current design is cleaner and provides a clearer path to reuse
between OpenACC and OpenMP implementations.

OpenACC Clarifications
----------------------

There are several issues related to the interpretation of the OpenACC
specification that we need to investigate further:

* The following event types never trigger when offloading is disabled
  (that is, `-fopenmp-targets` has not been specified), but this
  behavior is questionable:
    * `acc_ev_device_init_start`, `acc_ev_device_init_end`
    * `acc_ev_device_shutdown_start`, `acc_ev_device_shutdown_end`
    * `acc_ev_enqueue_upload_start`, `acc_ev_enqueue_upload_end`
    * `acc_ev_enqueue_download_start`, `acc_ev_enqueue_download_end`
    * `acc_ev_create`, `acc_ev_delete`, `acc_ev_alloc`, `acc_ev_free`
    * `acc_ev_enter_data_start`, `acc_ev_enter_data_end`
    * `acc_ev_exit_data_start`, `acc_ev_exit_data_end`
    * `acc_ev_update_start`, `acc_ev_update_end`
    * Notes:
        * pgcc 19.4-0 with `-ta:multicore` has the same behavior.
        * OpenACC 2.7 does not make it clear whether these event types
          should trigger when offloading is disabled.
* The following event types are among those that do trigger when
  offloading is disabled, but this behavior is questionable:
    * `acc_ev_enqueue_launch_start`, `acc_ev_enqueue_launch_end`
    * Notes:
        * pgcc 19.4-0 with `-ta:multicore` does not have this
          behavior.
        * OpenACC 2.7 does not make it clear whether these event types
          should trigger when offloading is disabled.
* `acc_ev_{enter,exit}_data_{start,end}`,
  `acc_ev_{create,alloc,delete}`, and
  `acc_ev_enqueue_{up,down}load_{start,end}` events trigger within the
  associated `acc_ev_compute_construct_{start,end}` event pair, but
  they trigger outside them instead when using pgcc 19.4-0.  Notes:
    * Either behavior appears to be permitted according to OpenACC 2.7
      sec. 5.1.7 L2825-2827, which says, "If there are data clauses on
      the compute construct, those data clauses may be treated as part
      of the compute construct, or as part of a data construct
      containing the compute construct."
    * We need to check more recent pgcc and discuss with the OpenACC
      technical committee.
* `acc_ev_create` triggers before the associated `acc_ev_alloc`, but
  they trigger in the reverse order when using pgcc 19.4-0.  Notes:
    * OpenACC 2.7 sec. 5.1.4 L2800-2802 says "An `acc_ev_create` event
      may be preceded by an `acc_ev_alloc` event, if newly allocated
      memory is used for this device data, or it may not, if the
      runtime manages its own memory pool."
    * This seems to encourage the Clacc behavior.
    * It's not clear if this permits the pgcc 19.4-0 behavior.
      Perhaps the `acc_ev_alloc` events represent enlargement of the
      memory pool after `acc_ev_create` events use up bytes there.
    * We need to check more recent pgcc and discuss with the OpenACC
      technical committee.
* pgcc 19.4-0 seems to trigger `acc_ev_delete` when it should trigger
  `acc_ev_free`, which it never seems to trigger.  Notes:
    * We need to check more recent pgcc and discuss with the OpenACC
      technical committee.
* Should any events trigger when transferring data between or within
  device memories?  Notes:
    * Such transfers can be performed using `acc_memcpy_device` (same
      device) or `acc_memcpy_d2d` (potentially different devices).
    * OpenACC 3.1 specifies `acc_ev_enqueue_{up,down}load_{start,end}`
      for copying data between local memory and device memory.  It
      does not specify events for transferring between device
      memories.  Moreover, would it be upload or download, or would
      both be triggered, relative to each device?
    * Clacc currently produces no OpenACC callbacks in these cases
      unless the implementation must transfer to/from local memory,
      either because one device is specified as the host or because a
      direct transfer between the specified devices is not possible.
    * Clacc's behavior seems to mimic nvc 20.9-0 behavior, at least
      when transferring within a single device's memory as nvc doesn't
      yet implement `acc_memcpy_d2d`.
    * Clacc assumes callbacks are not desirable if `acc_memcpy_d2d`
      specifies a transfer within local memory.
* OpenACC 2.7 specifies the typedef `acc_prof_lookup_func`, but it's
  spelled `acc_prof_lookup` in pgcc 19.4-0's `acc_prof.h`.  Notes:
    * Clacc's `acc_prof.h` typedefs one to the other in order to
      support OpenACC profiling libraries written for the OpenACC
      standard or for pgcc 19.4-0.
    * We need to check a more recent pgcc, and we will raise this
      discrepancy with the OpenACC technical committee.
* The triggering of `acc_ev_runtime_shutdown` is questionable because
  it never seems to trigger when using pgcc 19.4-0.
* How should the `device_number` and source location fields of
  `acc_prof_info` and the `parent_construct` and `implicit` fields of
  `acc_event_info` be set for `acc_ev_runtime_shutdown`?  Clacc
  currently sets `device_number` to the host device, source location
  fields to null, `parent_construct` to `acc_construct_runtime_api`,
  and `implicit` to `true`.  Likewise for
  `acc_ev_device_shutdown_start` and `acc_ev_device_shutdown_end`
  except Clacc sets `device_number` to the device being shut down.
  `acc_construct_runtime_api` really isn't appropriate in these cases,
  and OpenACC should probably specify a new member of
  `acc_construct_t` that makes sense for these events, perhaps
  `acc_construct_internal`.
* How should `vendor`, `device_handle`, `context_handle`, and
  `async_handle` fields of `acc_api_info` be assigned?
* The runtime first calls any linked `acc_register_library`, and then
  it calls the `acc_register_library` in every library listed in
  `ACC_PROFLIB` in the order the libraries are specified.  Notes:

    * pgcc 19.10-0 also calls them all and calls them in the order
      described above.
    * OpenACC 3.0 does not appear to specify whether the use of
      `ACC_PROFLIB` should suppress any already linked
      `acc_register_library`, or vice-versa.
    * OpenACC 3.0 sec. 5.3.3 L3531-3532 does specify the order for
      just `ACC_PROFLIB`:

        > The OpenACC runtime will open these libraries and invoke the
        > acc_register_library routine for each, in the order they
        > appear in ACC_PROFLIB.

* The runtime fails with a diagnostic if it fails to open any library
  listed in `ACC_PROFLIB` or to find an `acc_register_library`
  function in that library.  Notes:

    * pgcc 19.10-0 prints a diagnostic for failing to open such a
      library but does not terminate the runtime.  In this case,
      OpenACC 3.0 sec. 5.3.3 L3512-3514 permits both pgcc's and
      Clacc's behavior:

        > The runtime will open the dynamic library (using dlopen or
        > LoadLibraryA); if the library cannot be opened, the runtime
        > may abort, or may continue execution with or without an
        > error message.

    * pgcc 19.10-0 does not report a failure to find
      `acc_register_library` in such a library.  OpenACC 3.0 does not
      appear to clarify the behavior in this case.

Limitations
-----------

Limitations left to be resolved in Clacc's OpenACC Profiling Interface
support currently include:

* `acc_prof_register` and `acc_prof_unregister` must be called only
  via the pointers obtained within `acc_register_library` and must be
  called only within `acc_register_library`.  Notes:
    * That is, `acc_prof_register` and `acc_prof_unregister` cannot be
      linked and called directly, and the pointers passed to
      `acc_register_library` are not intended to be stored and used
      after `acc_register_library`.
    * The underlying issue is that whether OMPT callbacks are desired
      must be known at the time of `ompt_start_tool`, but OMPT
      callback registrations cannot be performed until the OpenMP
      runtime performs the `initialize` callback later.  The reason is
      that, if there are no callbacks, `ompt_start_tool` should return
      null to avoid unnecessarily enabling OMPT and potentially
      impacting OpenMP performance, but it's the `initialize` callback
      that receives pointers to functions like `ompt_set_callback`.
    * Clacc addresses this issue as follows.  `acc_prof_register` and
      `acc_prof_unregister` queue their registration actions instead
      of performing them immediately.  Clacc implements
      `ompt_start_tool` to call `acc_register_library` and to return
      null if `acc_register_library` leaves the registration queue
      empty.  Otherwise, Clacc's `ompt_start_tool` returns non-null
      and specifies an `initialize` callback that later iterates the
      queue and actually performs the required callback registrations.
    * In the future, Clacc may expose `acc_prof_register` and
      `acc_prof_unregister` for use outside of `acc_register_library`.
      They would queue their registration actions until the
      `initialize` callback is dispatched, and they would perform them
      directly afterward.
    * That change would entirely eliminate this limitation except
      that, if neither `acc_prof_register` or `acc_prof_unregister` is
      called by the time the OpenMP runtime calls `ompt_start_tool`,
      OMPT would not be enabled, so calling `acc_prof_register` or
      `acc_prof_unregister` afterward would have no effect.  To
      address that use case, Clacc's `ompt_start_tool` could be
      extended to check an environment variable or weakly linked
      function that specifies whether OMPT should always be enabled.
      Thus, the question of whether to enable profiling would become a
      link-time or run-time switch external to the OpenACC application
      and profiling library code.  When called too late,
      `acc_prof_register` and `acc_prof_unregister` should also
      produce warnings or errors advising the use of such a feature.
* For each event type, at most one occurrence of one callback can be
  registered at a time, and it cannot be toggled.  Notes:
    * This limits the usefulness of listing multiple libraries in
      `ACC_PROFLIB`.
    * OMPT does not appear to have such features.
    * Eliminating this limitation requires building more sophisticated
      OpenACC Profiling Interface callback registration tables.
* The following event types are not yet supported because the Clacc
  compiler does not yet implement directives and clauses that would
  trigger them:
    * `acc_ev_wait_start`, `acc_ev_wait_end`
* In the case of multiple devices of the same type, callbacks for
  `acc_ev_device_shutdown_start` and `acc_ev_device_shutdown_end` are
  currently grouped by device type.  That is, for any individual
  device, the difference in time between the dispatch of
  `acc_ev_device_shutdown_start` and `acc_ev_device_shutdown_end`
  always includes the time to finalize all devices of the same type
  and might include the time to execute those callbacks for some other
  devices of the same type.  In contrast, `acc_ev_device_init_start`
  and `acc_ev_device_init_end` are not grouped by device type.
* Some of the data passed to the OpenACC callbacks currently have
  questionable values or have been omitted:
    * The `valid_bytes` field is properly set in each of these structs
      to indicate which fields are omitted, as indicated below.
    * Information we do not know how to obtain via OMPT might require
      OMPT extensions.
    * Fields not mentioned below are expected to be correctly
      implemented.
    * `acc_prof_info`:
        * `thread_id` is always set to `0` currently.
        * `async` is always set to `acc_async_sync` because the Clacc
          compiler does not yet support the `async` clause.  Thus,
          this value appears to be correct according to OpenACC.
        * `async_queue` is always set to `-1` currently.  OpenACC 3.0
          sec. 5.2.1 L3356 says "If the runtime uses a limited number
          of asynchronous queues, this field contains the internal
          asynchronous queue number used for the event."  However, it
          doesn't say what the field contains if the runtime doesn't,
          so we have chosen `-1`.
        * All fields describing source location information:
            * We do not know how to obtain this information via OMPT.
            * When compiling the OpenACC application using Clacc's
              compiler in traditional compilation mode, these fields
              are set correctly.
            * When compiling the OpenACC application using Clacc's
              compiler in source-to-source mode followed by OpenMP
              compilation, these fields are nullified by default
              (except in the case of the `unknown` string described
              below).  However, they are set correctly when the
              generated OpenMP is compiled with Clacc's compiler and
              debug information is enabled with Clang command-line
              options like `-gline-tables-only` or `-g`.
            * See the section "OpenACC to OpenMP Mapping: Profiling
              Data" for further discussion.
            * Note that nullifying these fields is permitted by the
              OpenACC 3.1 specification, but actual source locations
              would obviously be preferable.
            * In some cases where `src_file` or `func_name` should be
              nullified to indicate it is not known, it is instead set
              to the string `unknown`, which is unfortunate because it
              is indistinguishable from an actual file or function by
              that name.  This issue is inherited from upstream LLVM's
              OpenMP debug info implementation.
    * `acc_event_info`:
        * `parent_construct` and `implicit`:
            * We do not know how to obtain this information via OMPT.
            * When compiling the OpenACC application using Clacc's
              compiler in traditional compilation mode, these fields
              are set correctly (but see the section "OpenACC
              Clarifications" above for the case of shutdown events).
            * When compiling the OpenACC application using Clacc's
              compiler in source-to-source mode followed by OpenMP
              compilation, these fields are, by default, set to
              `acc_construct_runtime_api` and `true` as if all events
              are triggered internally and thus have no connection
              back to specific directives or runtime calls.  This
              behavior does not conform to OpenACC 3.1.  However,
              these fields are set correctly when the generated OpenMP
              is compiled with Clacc's compiler and debug information
              is enabled with Clang command-line options like
              `-gline-tables-only` or `-g`.
            * See the section "OpenACC to OpenMP Mapping: Profiling
              Data" for further discussion.
        * `tool_info` is always set to `NULL`, and data cannot yet be
          shared between `_start` and `_end` events.  This should be
          one of the easier limitations to fix, if needed.
        * `acc_data_event_info`:
            * `var_name`:
                * We do not know how to obtain this field via OMPT.
                * When compiling the OpenACC application using Clacc's
                  compiler in traditional compilation mode, this field
                  is normally set correctly, but there are a few
                  caveats:
                    * OpenACC 3.0 specifies that this field contain
                      just a variable name.  Under Clacc, it can
                      include a more complex expression, such as a
                      subarray, if specified in an explicit data
                      clause.  We assume this extra information is
                      helpful for users.  If users instead report that
                      it is problematic for their OpenACC profiling
                      libraries, Clacc will be adjusted in the future
                      to fully conform to the spec.
                    * There exists at least one case where this field
                      is not supported and thus is set to `NULL`: when
                      the implementation choses to pack multiple small
                      firstprivate arrays into one allocation.  Please
                      report additional cases.
                * When compiling the OpenACC application using Clacc's
                  compiler in source-to-source mode followed by OpenMP
                  compilation, this field is set to `NULL` by default.
                  However, it is set correctly when the generated
                  OpenMP is compiled with Clacc's compiler and debug
                  information is enabled with Clang command-line
                  options like `-gline-tables-only` or `-g`.
                * See the section "OpenACC to OpenMP Mapping: Profiling
                  Data" for further discussion.
                * Note that setting this field to `NULL` is permitted
                  by OpenACC 3.1 when the variable name is not known.
        * `acc_launch_event_info`:
            * `kernel_name` is always set to `NULL` because we do not
              know how to obtain it via OMPT.  Setting to `NULL` is
              permitted by OpenACC.
            * `num_gangs`, `num_workers`, and `vector_length` are
              omitted because we do not know how to obtain them via
              OMPT:
                * The problem with `num_gangs` is that OpenACC 2.7
                  says it's the number of gangs *created*, but the
                  `ompt_callback_target_submit` callback only provides
                  the number of teams *requested*.  It might possible
                  to retrieve the required data from OMPT trace
                  records, but we have not implemented that support
                  yet.
                * The problem with `num_workers` and `vector_length`
                  is that, in contrast with OpenACC compute
                  directives, `num_threads` and `simdlen` are not
                  specified at the level of an OpenMP target
                  directive.
    * `acc_api_info`:
        * `device_api` is always set to `acc_device_api_none` because
          it's used to indicate the semantics of later fields we do
          not yet support.  Thus, this value appears to be correct
          according to OpenACC.
        * `vendor` is omitted because we do not know the right way to
          choose a vendor number (see "OpenACC Clarifications" above).
        * `device_handle`, `context_handle`, and `async_handle` are
          omitted because we have not yet determined how to properly
          support them (see "OpenACC Clarifications" above)
* Clacc's OpenACC Profiling Interface support is an early prototype
  and needs more thorough testing with real OpenACC applications and
  profiling libraries.  In particular, we took shortcuts in our
  extensions to LLVM's OMPT support, and there might be issues with,
  for example, thread safety.
* Clacc's OpenACC Profiling Interface support depends on OMPT
  extensions.  As a result, any OpenMP runtime implementation must
  support some of these extensions to be usable.  Moreover, any OpenMP
  compiler used after Clacc's source-to-source mode when compiling an
  OpenACC application must support the extensions, or some profiling
  data will not be available or will be inaccurate.  Notes:
    * A graceful mechanism to reject registration of OpenACC event
      types for which required OMPT callbacks are not supported by the
      linked OpenMP runtime should be devised.
    * That mechanism could also handle standard OMPT callbacks not
      supported by the linked OpenMP runtime.
