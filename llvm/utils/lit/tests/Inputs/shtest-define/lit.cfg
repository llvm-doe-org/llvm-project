import lit.formats
config.name = 'shtest-define'
config.suffixes = ['.txt']
config.test_format = lit.formats.ShTest()
config.test_source_root = None
config.test_exec_root = None

# When config.recursiveExpansionLimit is not specified, it's important to
# prepend substitutions before substitutions they might now or later (upon a
# redefinition) depend upon.  For example, %{global:greeting} and %{global:what}
# act as parameters for %{global:echo}, so we make sure the latter expands
# before the former.  Moreover, some tests redefine %{global:greeting} in terms
# of %{global:what}, so we make sure the former expands before the latter.
# If we always insert at the beginning fo the substitution list (as DEFINE
# does), then the rule is simple: define a substitution before you refer to it.
config.substitutions.insert(0, ('%{global:what}', 'World'))
config.substitutions.insert(0, ('%{global:greeting}', ''))
config.substitutions.insert(0,
    ('%{global:echo}', "echo GLOBAL: %{global:greeting} %{global:what}"))

# Neither 'DEFINE:' or 'REDEFINE:' can (re)define any of the '%{global:*}'
# contained in these patterns.
config.substitutions.insert(0, ('<%{global:inside}>', '<@>'))
config.substitutions.insert(0, (r'%{global:prefix}\((.*)\)', r'@(\g<1>)'))
config.substitutions.insert(0, ('@%{global:suffix}', '@@'))

# These cannot be redefined by 'REDEFINE:', which doesn't know which one to
# redefine.
config.substitutions.insert(0, ('%{global:multiple-exact}', 'first'))
config.substitutions.insert(0, ('%{global:multiple-exact}', 'second'))

# '%{global:multiple-once-exact}' cannot be redefined by 'REDEFINE:' even though
# it's only defined once.
config.substitutions.insert(0, ('%{global:multiple-once-exact}', '@'))
config.substitutions.insert(0, ('<%{global:multiple-once-exact}>', '<@>'))

recur = lit_config.params.get('recur', None)
if recur:
  config.recursiveExpansionLimit = int(recur)