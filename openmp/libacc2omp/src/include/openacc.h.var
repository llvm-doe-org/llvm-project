/*
 * include/openacc.h.var
 */

//===----------------------------------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef __OPENACC__
#define __OPENACC__

// For standard types (e.g., size_t) used in OpenACC spec's declarations.
#include <stddef.h>

#ifdef __cplusplus
extern "C" {
#endif

//------------------------------------------------------------------------------
// OpenACC Types.
//------------------------------------------------------------------------------

#define ACC2OMP_FOREACH_ARCH_DEVICE(Macro)                                     \
  Macro(nvidia)                                                                \
  Macro(radeon)                                                                \
  Macro(x86_64)                                                                \
  Macro(ppc64le)

#define ACC2OMP_FOREACH_DEVICE(Macro)                                          \
  Macro(none)                                                                  \
  Macro(host)                                                                  \
  Macro(not_host)                                                              \
  Macro(default)                                                               \
  Macro(current)                                                               \
  ACC2OMP_FOREACH_ARCH_DEVICE(Macro)

typedef enum {
#define ACC2OMP_DEVICE_ENUMERATOR(Device)                                      \
  acc_device_##Device,
  ACC2OMP_FOREACH_DEVICE(ACC2OMP_DEVICE_ENUMERATOR)
#undef ACC2OMP_DEVICE_ENUMERATOR
} acc_device_t;

// These enumerator values must be kept in sync with the associated enum in
// ACCAsyncClause in clang/include/clang/AST/OpenACCClause.h.
#define ACC2OMP_FOREACH_ASYNC(Macro)                                           \
  Macro(sync,    -1)                                                           \
  Macro(noval,   -2)                                                           \
  Macro(default, -3)

enum {
#define ACC2OMP_ASYNC_ENUMERATOR(Async, Val)                                   \
  acc_async_##Async = Val,
  ACC2OMP_FOREACH_ASYNC(ACC2OMP_ASYNC_ENUMERATOR)
#undef ACC2OMP_ASYNC_ENUMERATOR
};

//------------------------------------------------------------------------------
// OpenACC device management routines.
//------------------------------------------------------------------------------

int acc_get_num_devices(acc_device_t dev_type);
void acc_set_device_type(acc_device_t dev_type);
acc_device_t acc_get_device_type();
void acc_set_device_num(int dev_num, acc_device_t dev_type);
int acc_get_device_num(acc_device_t dev_type);

//------------------------------------------------------------------------------
// OpenACC async/wait management routines.
//------------------------------------------------------------------------------

int acc_get_default_async(void);
void acc_set_default_async(int async_arg);

//------------------------------------------------------------------------------
// OpenACC device test routine (acc_on_device).
//
// Either of the following errors indicates the current architecture isn't yet
// handled in this file for the sake of acc_on_device.
//
// - error: use of undeclared identifier 'acc2omp_device_arch'
// - Undefined reference to 'acc2omp_unexpected_device_arch'
//
// To fix that, add a new enumerator to acc_device_t above, and add a
// corresponding ACC2OMP_DEVICE_VARIANT invocation to the list at the end of
// this section.
//
// When not using an installed Clang in traditional OpenACC compilation mode,
// there are several caveats about acc_on_device:
//
// - If both OpenACC and OpenMP are disabled, this header defines acc_on_device
//   so it returns true only if its argument is acc_device_host:
//   - This behavior appears to follow nvc 21.7-0's behavior.
//   - This behavior makes sense as offloading is disabled if OpenACC and OpenMP
//     are disabled.
// - If OpenMP is enabled, this header defines acc_on_device so it behaves for
//   OpenMP target regions as it would for OpenACC compute constructs if OpenACC
//   were enabled:
//   - The reason is that the definition of acc_on_device below employs OpenMP
//     variant directives so that acc_on_device behaves correctly for OpenMP
//     compilation after using Clang's OpenACC source-to-source mode, which
//     does not rewrite acc_on_device calls.
//   - This behavior does not appear to follow nvc 21.7-0's behavior.
// - When OpenACC is enabled, Clang enables OpenMP only in system headers:
//   - Fortunately, an installed Clang treats this header as a system header.
//   - However, from Clang's build directory, Clang's -isystem command-line
//     option might be needed.
// - OpenMP enum variant support is required for acc_on_device calls to evaluate
//   as constant expressions:
//   - Such constant evaluations are specified by OpenACC 3.1, sec. 3.2.23
//     "acc_on_device", L3415-3416: "If the acc_on_device routine has a
//     compile-time constant argument, it evaluates at compile time to a
//     constant."
//   - OpenMP 5.1 doesn't specify enum variants.  Currently, Clang supports this
//     extension as required here except when using -fopenacc-ast-print, as
//     described below.
//   - If an OpenMP compiler doesn't support enum variants, the preprocessor
//     macro ACC2OMP_ENUM_VARIANTS_SUPPORTED should be set to 0 before including
//     this header.  Otherwise, the acc_on_device definition below may fail to
//     compile or may compile incorrectly.  Passing
//     -DACC2OMP_ENUM_VARIANTS_SUPPORTED=0 to the OpenMP compiler should be
//     sufficient.
//   - A better solution is to extend this header to detect such an OpenMP
//     compiler via compiler-specific preprocessor definitions and then set
//     #define ACC2OMP_ENUM_VARIANTS_SUPPORTED 0.
//   - When ACC2OMP_ENUM_VARIANTS_SUPPORTED is set to 0, strict compilers will
//     not permit acc_on_device calls in contexts where constant expressions are
//     required.  Even so, compilers might still be able to optimize
//     acc_on_device calls as constant expressions in other contexts.
// - When Clang's OpenACC source-to-source mode is enabled by
//   -fopenacc-ast-print instead of -fopenacc-print, acc_on_device currently
//   behaves as if always called on the host because Clang's AST printing
//   facility currently does not print OpenMP variants correctly.
//------------------------------------------------------------------------------

#ifndef ACC2OMP_ENUM_VARIANTS_SUPPORTED
# define ACC2OMP_ENUM_VARIANTS_SUPPORTED 1
#endif

#if _OPENMP

#define ACC2OMP_STR(Arg) #Arg

#if ACC2OMP_ENUM_VARIANTS_SUPPORTED

# define ACC2OMP_DEVICE_VARIANT(TName, TValue, DevType)                        \
_Pragma(ACC2OMP_STR(omp begin declare variant match(device={TName(TValue)})))  \
enum {acc2omp_device_##TName = DevType};                                       \
_Pragma("omp end declare variant")

// To handle compile errors complaining that acc2omp_device_arch is undeclared
// at acc_on_device calls, see comments at the beginning of this section.
# define acc2omp_get_device_kind() acc2omp_device_kind
# define acc2omp_get_device_arch() acc2omp_device_arch

#else // !ACC2OMP_ENUM_VARIANTS_SUPPORTED

# define ACC2OMP_DEVICE_VARIANT(TName, TValue, DevType)                        \
_Pragma(ACC2OMP_STR(omp begin declare variant match(device={TName(TValue)})))  \
static inline acc_device_t acc2omp_get_device_##TName() {                      \
  return DevType;                                                              \
}                                                                              \
_Pragma("omp end declare variant")

static inline acc_device_t acc2omp_get_device_kind() {
  acc_device_t acc2omp_unexpected_device_kind();
  return acc2omp_unexpected_device_kind();
}
static inline acc_device_t acc2omp_get_device_arch() {
  // To handle link errors for acc2omp_unexpected_device_arch, see comments at
  // the beginning of this section.
  acc_device_t acc2omp_unexpected_device_arch();
  return acc2omp_unexpected_device_arch();
}

#endif // ACC2OMP_ENUM_VARIANTS_SUPPORTED

ACC2OMP_DEVICE_VARIANT(kind, host,    acc_device_host)
ACC2OMP_DEVICE_VARIANT(kind, nohost,  acc_device_not_host)
ACC2OMP_DEVICE_VARIANT(arch, nvptx64, acc_device_nvidia)
ACC2OMP_DEVICE_VARIANT(arch, amdgcn,  acc_device_radeon)
ACC2OMP_DEVICE_VARIANT(arch, x86_64,  acc_device_x86_64)
ACC2OMP_DEVICE_VARIANT(arch, ppc64le, acc_device_ppc64le)
#undef ACC2OMP_DEVICE_VARIANT
#undef ACC2OMP_STR

#define acc_on_device(DevType)                                                 \
  ((int)(acc2omp_get_device_kind() == DevType ||                               \
         (acc2omp_get_device_kind() == acc_device_not_host &&                  \
          acc2omp_get_device_arch() == DevType)))

#else // !_OPENMP

#define acc_on_device(DevType) ((int)(acc_device_host == DevType))

#endif // _OPENMP

//------------------------------------------------------------------------------
// OpenACC data and memory management routines.
//------------------------------------------------------------------------------

void *acc_malloc(size_t bytes);
void acc_free(void *data_dev);
void *acc_copyin(void *data_arg, size_t bytes);
void *acc_present_or_copyin(void *data_arg, size_t bytes);
void *acc_pcopyin(void *data_arg, size_t bytes);
void *acc_create(void *data_arg, size_t bytes);
void *acc_present_or_create(void *data_arg, size_t bytes);
void *acc_pcreate(void *data_arg, size_t bytes);
void acc_copyout(void *data_arg, size_t bytes);
void acc_copyout_finalize(void *data_arg, size_t bytes);
void acc_delete(void *data_arg, size_t bytes);
void acc_delete_finalize(void *data_arg, size_t bytes);
void acc_update_device(void *data_arg, size_t bytes);
void acc_update_self(void *data_arg, size_t bytes);
void acc_map_data(void* data_arg, void* data_dev, size_t bytes);
void acc_unmap_data(void* data_arg);
void *acc_deviceptr(void *data_arg);
void *acc_hostptr(void *data_dev);
int acc_is_present(void *data_arg, size_t bytes);
void acc_memcpy_to_device(void *data_dev_dest, void *data_host_src,
                          size_t bytes);
void acc_memcpy_from_device(void *data_host_dest, void *data_dev_src,
                            size_t bytes);
void acc_memcpy_device(void *data_dev_dest, void *data_dev_src, size_t bytes);
void acc_memcpy_d2d(void *data_arg_dest, void *data_arg_src, size_t bytes,
                    int dev_num_dest, int dev_num_src);

//------------------------------------------------------------------------------
// libacc2omp-provided declarations used in Clang's OpenMP translation of
// OpenACC directives and in libacc2omp's implementation of OpenACC runtime
// library routines.  These are not intended for direct use within OpenACC
// application source code.
//------------------------------------------------------------------------------

/// \p async_arg must be an OpenACC \c async-argument, which can be used to
/// select an activity queue in an \c async or \c wait clause, \c wait
/// directive, or an asynchronous runtime library routine.  Return the host
/// memory address that uniquely identifies the selected activity queue in
/// OpenMP \c depend clauses produced by Clang's translation of OpenACC
/// directives.  The return type of \c char* is convenient for dereferencing to
/// produce an lvalue in a \c depend clause (\c void* would be less convenient),
/// and it reflects that host memory addresses identifying other activity queues
/// might be just one byte away.
char *acc2omp_async2dep(int async_arg);

#ifdef __cplusplus
} // extern "C"
#endif

#endif // __OPENACC__
