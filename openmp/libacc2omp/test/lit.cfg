# -*- Python -*- vim: set ft=python ts=4 sw=4 expandtab tw=79:
# Configuration file for the 'lit' test runner.
#
# Every test is replicated in multiple sub test suites, each of which compiles
# the test with a different offload configuration:
#
# * "host" selects no device types for offload compilation.
# * Each architecture-specific sub test suite ("x86_64-pc-linux-gnu",
#   "nvptx64-nvidia-cuda", etc.) selects just one device type for offload
#   compilation.  The sub test suite is omitted if that device type is not
#   available on the system.
# * "multitarget" selects all available device types on the system for offload
#   compilation.  Only tests whose file names have the suffix ".multi.c" or
#   ".multi.cpp" are placed in this sub test suite.
#
# For each sub test suite, its name as well as the target triples it selects for
# offload compilation are added to the LIT features that can be used in
# REQUIRES, UNSUPPORTED, and XFAIL.
#
# The behavior of LIT substitutions often depends on the device types selected
# for offload compilation.  Substitutions are documented where they are defined
# below.

import os
import re
import subprocess
import lit.formats
from lit.llvm.subst import ToolSubst

# Tell pylint that we know config and lit_config exist somewhere.
if 'PYLINT_IMPORT' in os.environ:
    config = object()
    lit_config = object()

def append_dynamic_library_path(name, value):
    sep = ':'
    if name in config.environment:
        config.environment[name] = value + sep + config.environment[name]
    else:
        config.environment[name] = value

# name: The name of this test suite.
config.name = 'libacc2omp :: ' + config.libacc2omp_current_target

# suffixes: A list of file extensions to treat as test files.
config.excludes = ['Inputs']
if config.libacc2omp_current_target == 'multitarget':
  config.suffixes = ['.multi.c', '.multi.cpp']
else:
  config.suffixes = ['.c', '.cpp']

# test_source_root: The root path where tests are located.
config.test_source_root = os.path.dirname(__file__)

# test_exec_root: The root object directory where output is placed
config.test_exec_root = config.libacc2omp_obj_root

# Use lit's internal shell to help guarantee test portability.
config.test_format = lit.formats.ShTest(execute_external=False)

# Diagnose unexpanded substitutions.
config.recursiveExpansionLimit=1

# Allow REQUIRES / UNSUPPORTED / XFAIL to work
config.target_triple = [ ]
for feature in config.test_compiler_features:
    config.available_features.add(feature)
config.available_features.add(config.libacc2omp_current_target)
if config.libacc2omp_current_target == 'multitarget':
    config.available_features.update(config.libacc2omp_system_targets)

# Set up environment to find libraries at run time
append_dynamic_library_path('LD_LIBRARY_PATH', config.libacc2omp_dir)
append_dynamic_library_path('LD_LIBRARY_PATH', config.libomp_dir)
append_dynamic_library_path('LD_LIBRARY_PATH', config.libomptarget_dir)

#-------------------------------------------------------------------------------
# Various helpers used to implement substitutions below.

# Convert target triple to omp_device_t spelling.  tgt="host" returns "host".
def tgtToOMP(tgt):
    tgt_short = tgt.split('-')[0]
    if tgt_short == "powerpc64le":
        return "ppc64le"
    return tgt_short

# Convert target triple to acc_device_t spelling.  tgt="host" returns "host".
def tgtToACC(tgt):
    tgt_short = tgtToOMP(tgt)
    if tgt_short == "nvptx64":
        return "nvidia"
    if tgt_short == "amdgcn":
        return "radeon"
    return tgt_short

# Does this target triple support stdio (like printf)?
def tgtSupportsStdio(tgt):
    # FIXME: amdgcn should eventually support printf in a target region.
    return tgtToOMP(tgt) != "amdgcn"

# Does LLVM's implementation for this target triple perform intra-device data
# copies directly ("direct") or via the host ("by-host")?  tgt="host" returns
# "direct".
def tgtCopy(tgt):
    tgt_short = tgt.split('-')[0]
    if tgt_short == "host" or tgt_short == "nvptx64":
        return "direct"
    return "by-host"

#-------------------------------------------------------------------------------
# %clang-*
#
# These are substitutions expanding to Clang commands for compiling OpenACC
# and generated OpenMP code:
# * %clang-acc compiles an OpenACC application for the selected device types.
# * %clang-acc-prt-omp uses -fopenacc-print=omp to translate OpenACC to OpenMP.
#   It includes options to suppress Clacc's typical source-to-source errors
#   about OpenMP extensions.
# * %clang-omp compiles OpenMP code for the selected device types.  It expects
#   the OpenMP code was generated by %clang-acc-prt-omp.
# * %clang-acc-fsyntax-only is for performing a Clang syntax check of OpenACC
#   code.  Thus, it includes -fsyntax-only but not -fopenmp-targets.
# * %clang-noacc compiles plain C code (that possibly includes
#   libacc2omp-provided headers).
# * %clang-lib is the same as %clang-noacc but adds options for compiling into a
#   shared object.  For example, this makes sense for OpenACC profiling
#   libraries and alternate libacc2omp backends.
#
# Common behavior:
# * All substitutions include options for required OpenACC/OpenMP includes and
#   libraries.
# * No substitution includes source file arguments, the "-o" option, pipelines,
#   or file redirects.
# * All substitutions include "-verify" options:
#   * The "expected" prefix is always enabled.  The "host" prefix is enabled
#     only for the "host" sub test suite.  For other sub test suites, prefixes
#     are enabled based on the omp_device_t spellings of the selected offload
#     device types (e.g., "x86_64", "nvptx64") if the substitution compiles for
#     offloading.
#   * To expect no diagnostics for all cases:
#
#       // expected-no-diagnostics
#
#   * To expect diagnostics for nvptx64 but not for any other case:
#
#       // expected-error 0 {{}}
#       // nvptx64-warning@*:* 1+ {{Linking two modules of different target triples}}
#
#   * FIXME: It would be nice if "-verify" supported an
#     "expected-no-other-diagnostics", which would have the same semantics as
#     "expected-no-diagnostics" except it would be ignored when any other
#     directive is specified.  That is, it would behave like
#     "expected-error 0 {{}}", but its intention would be clearer.

# Select device types for offload compilation based on the sub test suite and on
# the devices actually enabled.  Mark the sub test suite as unsupported if no
# device of any of the sub test suite's device types is enabled.
test_msg = None
if config.libacc2omp_current_target == 'host':
    selected_tgts = ['host']
    tgt_to_ndevs = {'host': 1}
    fopenmp_targets = ''
else:
    if config.libacc2omp_current_target == 'multitarget':
        selected_tgts = config.libacc2omp_system_targets
    else:
        selected_tgts = [config.libacc2omp_current_target]
    dev_info = subprocess.run(
      config.test_llvm_omp_device_info, check=True, stdout=subprocess.PIPE,
      stderr=subprocess.PIPE, universal_newlines=True,
      env=config.environment).stdout
    tgt_to_ndevs = {tgt: len(re.findall("omp_device_" + tgtToOMP(tgt),
                                        dev_info))
                    for tgt in selected_tgts}
    selected_tgts = [tgt for tgt in selected_tgts if tgt_to_ndevs[tgt] > 0]
    if len(selected_tgts) > 0:
        if len(selected_tgts) < len(list(tgt_to_ndevs)):
            test_msg = 'removing device types with no enabled devices'
        fopenmp_targets = ' -fopenmp-targets=' + str.join(',', selected_tgts)
    else:
        config.unsupported = True
        test_msg = 'marking tests unsupported because no devices are enabled'
        # No tests will run, but we need to set some values that will keep the
        # rest of the script from crashing.
        selected_tgts = list(tgt_to_ndevs)
        fopenmp_targets = ''
lit_config.note("Device counts for '{name}': {counts}{msg}".format(
                  name=config.name, counts=str(tgt_to_ndevs),
                  msg=' (' + test_msg + ')' if test_msg else ''))

# The OpenMP version required by the OpenACC implementation.
fopenmp_version = ' -fopenmp-version=51'

# Diagnostic options.
verify = ' -Xclang -verify=expected'
verify_noacc = verify + ',noacc'
verify_tgts = verify
for tgt in selected_tgts:
    verify_tgts += "," + tgtToOMP(tgt)

# Header and library options.
incs = ' -isystem {acc} -isystem {omp}'.format(
  acc=config.acc2omp_header_directory, omp=config.omp_header_directory)
acc_libs = ' -lacc2omp'
bc_libs = ''
if any(tgtToOMP(tgt) == "amdgcn" for tgt in selected_tgts):
    bc_libs += " --libomptarget-amdgcn-bc-path=" + config.libomptarget_dir
if any(tgtToOMP(tgt) == "nvptx64" for tgt in selected_tgts):
    bc_libs += " --libomptarget-nvptx-bc-path=" + config.libomptarget_dir

# Start with plain clang.
clang = config.test_c_compiler

# Generally, we need to be aware of dead code in our tests, especially because
# unused static functions might be test cases that are accidentally not invoked.
clang += " -Werror=unused-function"

# Make sure the build's libraries are used not the system's.
clang += " -L " + config.libacc2omp_dir
clang += " -L " + config.libomp_dir
clang += " -L " + config.libomptarget_dir

# %clang-*
config.substitutions.append(('%clang-noacc',
  clang + incs + verify_noacc))
config.substitutions.append(('%clang-lib',
  clang + incs + verify_noacc + ' -shared -fpic'))
config.substitutions.append(('%clang-acc-prt-omp',
  clang + ' -fopenacc-print=omp' + incs + verify + ' -Wno-openacc-omp-ext'))
config.substitutions.append(('%clang-acc-fsyntax-only',
  clang + ' -fopenacc -fsyntax-only' + incs + verify))
# Add %clang-acc after %clang-acc-* or the latter will never substitute.
config.substitutions.append(('%clang-acc',
  clang + ' -fopenacc' + fopenmp_targets + bc_libs + incs + verify_tgts))
config.substitutions.append(('%clang-omp',
  clang + ' -fopenmp' + fopenmp_version + bc_libs + fopenmp_targets + incs + \
  verify_tgts + acc_libs))

#-------------------------------------------------------------------------------
# %if-COND<TRUE|FALSE>
#
# COND values:
# * "host" indicates compilation only for host (i.e., "host" sub test suite).
# * "multi" indicates compilation for multiple offload device types (i.e.,
#   "multitarget" sub test suite).
# * "tgt-stdio" indicates that all device types selected for compilation support
#   stdio (e.g., "printf") in target regions.
#
# Common behavior:
# * Expands to TRUE if the condition indicated by COND is true, and expands to
#   FALSE otherwise.
# * TRUE and FALSE cannot include any character in the set "<>|".  As a result,
#   these substitutions cannot appear in each other's arguments.
# * Either TRUE or FALSE can be the empty string.
# * "|" cannot be omitted even if FALSE is the empty string.  Otherwise, it's
#   too easy to read any comma within TRUE as the delimiter.
# * These substitutions are designed to avoid syntactic ambiguity when TRUE or
#   FALSE contains commas (e.g., for delimiting FileCheck prefix components).

config.substitutions.append(('%if-host<([^<>|]*)\|([^<>|]*)>',
  '\\1' if config.libacc2omp_current_target == 'host' else '\\2'))
config.substitutions.append(('%if-multi<([^<>|]*)\|([^<>|]*)>',
  '\\1' if len(selected_tgts) > 1 else '\\2'))
config.substitutions.append(('%if-tgt-stdio<([^<>|]*)\|([^<>|]*)>',
  '\\1' if any(tgtSupportsStdio(tgt) for tgt in selected_tgts) else '\\2'))

#-------------------------------------------------------------------------------
# %dev-type-N-ATTR
#
# N = "0" or "1" to specify the first or last offload device type selected for
# compilation:
# - Both indicate host in the case of the "host" sub test suite, and they do not
#   indicate host in any other sub test suite.
# - Except in the case of the "multitarget" sub test suite, these are always the
#   same and are the type of OpenMP device number 0, the default offload device
#   selected by LLVM's implementation.
# - In the case of the "multitarget" sub test suite, these are not the same, and
#   there is no guarantee that OpenMP device number 0 or the default offload
#   device will have the first offload device type selected for compilation.
#   TODO: Until approximately May, 2022 (in upstream LLVM commits), the default
#   offload device had the first type specified in the -fopenmp-targets
#   argument.  Afterward, we found that the order in -fopenmp-targets argument
#   was irrelevant.  Moreover, we found that, even among machines that had only
#   x86_64 and nvptx64 offload devices, it varied which type the default offload
#   device was.  If we figure out how to determine the default offload device
#   type again, we can then improve test coverage by addressing related todos
#   throughout the "multitarget" sub test suite.
#
# ATTR specifies an attribute of the specified device type:
# * "acc", "ACC", "omp", or "OMP" specifies the acc_device_t or omp_device_t
#   spelling, either lowercase or uppercase, for the specified device type.  For
#   example, for an NVIDIA GPU, the expansion is "nvidia", "NVIDIA", "nvptx64",
#   or "NVPTX64", respectively.  For the "host" sub test suite, "acc" and "omp"
#   specify expansion to "host", and "ACC" and "OMP" specify expansion to
#   "HOST".
# * "num-devs" specifies the number of devices of that type.  For the "host" sub
#   test suite, it's always 1.
# * "last-dev" specifies the value of "num-devs" - 1.
# * "copy" specifies whether LLVM's implementation performs intra-device data
#   copies directly (expands to "direct") or via the host (expands to
#   "by-host").  In the case of the "host" sub test suite, it always expands to
#   "direct".

tgt0 = selected_tgts[0]
tgt1 = selected_tgts[-1]
config.substitutions.append(('%dev-type-0-acc', tgtToACC(tgt0)))
config.substitutions.append(('%dev-type-0-omp', tgtToOMP(tgt0)))
config.substitutions.append(('%dev-type-0-ACC', str.upper(tgtToACC(tgt0))))
config.substitutions.append(('%dev-type-0-OMP', str.upper(tgtToOMP(tgt0))))
config.substitutions.append(('%dev-type-1-acc', tgtToACC(tgt1)))
config.substitutions.append(('%dev-type-1-omp', tgtToOMP(tgt1)))
config.substitutions.append(('%dev-type-1-ACC', str.upper(tgtToACC(tgt1))))
config.substitutions.append(('%dev-type-1-OMP', str.upper(tgtToOMP(tgt1))))
config.substitutions.append(('%dev-type-0-num-devs', tgt_to_ndevs[tgt0]))
config.substitutions.append(('%dev-type-1-num-devs', tgt_to_ndevs[tgt1]))
config.substitutions.append(('%dev-type-0-last-dev', tgt_to_ndevs[tgt0] - 1))
config.substitutions.append(('%dev-type-1-last-dev', tgt_to_ndevs[tgt1] - 1))
config.substitutions.append(('%dev-type-0-copy', tgtCopy(tgt0)))
config.substitutions.append(('%dev-type-1-copy', tgtCopy(tgt1)))

#-------------------------------------------------------------------------------
# Other device data.
#
# %OMP-DEV-num-devs
# * OMP-DEV is the omp_device_t spelling of an offload device type.  For
#   example, "x86_64" or "nvptx64" but not "host".
# * Expands to the number of devices of the specified offload device type if it
#   is selected for compilation.  Expands to 0 otherwise.
#
# %bad-dev-type-acc
# * Expands to the acc_device_t spelling of one arbitrarily selected offload
#   device type that is not selected for compilation.  For example, "x86_64" or
#   "nvidia".
#
# %not-host-num-devs
# * Expands to the number of devices that are of offload device types selected
#   for compilation.  In other words, it's the number of devices that are
#   indicated by "acc_device_not_host".

found_bad = False
for tgt in config.libacc2omp_all_targets:
    tgt_omp = tgtToOMP(tgt)
    if tgt == "host":
        config.substitutions.append(("%" + tgt_omp + "-num-devs", "1"))
    elif tgt in selected_tgts:
        config.substitutions.append(("%" + tgt_omp + "-num-devs",
                                     tgt_to_ndevs[tgt]))
    else:
        config.substitutions.append(("%" + tgt_omp + "-num-devs", "0"))
        if tgtToOMP(tgt) in ["x86_64", "ppc64le", "nvptx64", "amdgcn"]:
            found_bad = True
            config.substitutions.append(("%bad-dev-type-acc",
                                         tgtToACC(tgt)))
assert found_bad and "didn't expect system with all possible target types"

not_host_num_devs = 0
if config.libacc2omp_current_target != 'host':
    for tgt in selected_tgts:
        not_host_num_devs += tgt_to_ndevs[tgt]
config.substitutions.append(('%not-host-num-devs', not_host_num_devs))

#-------------------------------------------------------------------------------
# Miscellaneous substitutions.

# %not is the usual "not" used throughout LLVM's test suites.
config.substitutions.append(("%not", config.test_not))

# FileCheck defaults to complaining about unused prefixes, but we have many.
config.substitutions.append((r"(?<!/)\bFileCheck",
    config.test_filecheck + " --allow-unused-prefixes"))

# %preload-t.so preloads %t.so, which the test should have already compiled.
config.substitutions.append(("%preload-t.so", "env LD_PRELOAD=%t.so"))

# The OpenACC version reported throughout Clang's implementation.
config.substitutions.append(('%acc-version', '202011'))
