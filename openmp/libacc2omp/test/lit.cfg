# -*- Python -*- vim: set ft=python ts=4 sw=4 expandtab tw=79:
# Configuration file for the 'lit' test runner.
#
# Every test is replicated in multiple sub test suites, each of which compiles
# the test with a different offload configuration:
#
# * "host" selects no device types for offload compilation.
# * Each architecture-specific sub test suite ("x86_64-pc-linux-gnu",
#   "nvptx64-nvidia-cuda", etc.) selects just one device type for offload
#   compilation.  The sub test suite is omitted if that device type is not
#   available on the system.
# * "multitarget" selects all available device types on the system for offload
#   compilation.  Only tests whose file names have the suffix ".multi.c" or
#   ".multi.cpp" are placed in this sub test suite.
#
# For each sub test suite, its name as well as the target triples it selects for
# offload compilation are added to the LIT features that can be used in
# REQUIRES, UNSUPPORTED, and XFAIL.
#
# The behavior of LIT substitutions often depends on the device types selected
# for offload compilation.  Substitutions are documented where they are defined
# below.

import os
import re
import subprocess
import lit.formats
from lit.llvm.subst import ToolSubst

# Tell pylint that we know config and lit_config exist somewhere.
if 'PYLINT_IMPORT' in os.environ:
    config = object()
    lit_config = object()

def append_dynamic_library_path(name, value):
    sep = ':'
    if name in config.environment:
        config.environment[name] = value + sep + config.environment[name]
    else:
        config.environment[name] = value

# name: The name of this test suite.
config.name = 'libacc2omp :: ' + config.libacc2omp_current_target

# suffixes: A list of file extensions to treat as test files.
config.excludes = ['Inputs']
if config.libacc2omp_current_target == 'multitarget':
  config.suffixes = ['.multi.c', '.multi.cpp']
else:
  config.suffixes = ['.c', '.cpp']

# test_source_root: The root path where tests are located.
config.test_source_root = os.path.dirname(__file__)

# test_exec_root: The root object directory where output is placed
config.test_exec_root = config.libacc2omp_obj_root

# Use lit's internal shell to help guarantee test portability.
config.test_format = lit.formats.ShTest(execute_external=False)

# Allow REQUIRES / UNSUPPORTED / XFAIL to work
config.target_triple = [ ]
for feature in config.test_compiler_features:
    config.available_features.add(feature)
config.available_features.add(config.libacc2omp_current_target)
if config.libacc2omp_current_target == 'multitarget':
    config.available_features.update(config.libacc2omp_system_targets)

# Set up environment to find libraries at run time
append_dynamic_library_path('LD_LIBRARY_PATH', config.libacc2omp_dir)
append_dynamic_library_path('LD_LIBRARY_PATH', config.libomp_dir)
append_dynamic_library_path('LD_LIBRARY_PATH', config.libomptarget_dir)

#-------------------------------------------------------------------------------
# Various helpers used to implement substitutions below.

# Convert target triple to omp_device_t spelling.  tgt="host" returns "host".
def tgtToOMP(tgt):
    tgt_short = tgt.split('-')[0]
    if tgt_short == "powerpc64le":
        return "ppc64le"
    return tgt_short

# Convert target triple to acc_device_t spelling.  tgt="host" returns "host".
def tgtToACC(tgt):
    tgt_short = tgtToOMP(tgt)
    if tgt_short == "nvptx64":
        return "nvidia"
    if tgt_short == "amdgcn":
        return "radeon"
    return tgt_short

# Does this target triple support stdio (like printf)?
def tgtSupportsStdio(tgt):
    # FIXME: amdgcn should eventually support printf in a target region.
    return tgtToOMP(tgt) != "amdgcn"

# Does LLVM's implementation for this target triple perform intra-device data
# copies directly ("direct") or via the host ("by-host")?  tgt="host" returns
# "direct".
def tgtCopy(tgt):
    tgt_short = tgt.split('-')[0]
    if tgt_short == "host" or tgt_short == "nvptx64":
        return "direct"
    return "by-host"

#-------------------------------------------------------------------------------
# %clang-*
#
# These are substitutions expanding to Clang commands for compiling OpenACC
# and generated OpenMP code:
# * %clang-acc compiles an OpenACC application for the selected device types.
# * %clang-acc-prt-omp uses -fopenacc-print=omp to translate OpenACC to OpenMP.
#   It includes options to suppress Clacc's typical source-to-source errors
#   about OpenMP extensions.
# * %clang-omp compiles OpenMP code for the selected device types.  It expects
#   the OpenMP code was generated by %clang-acc-prt-omp.
# * %clang-acc-fsyntax-only is for performing a Clang syntax check of OpenACC
#   code.  Thus, it includes -fsyntax-only but not -fopenmp-targets.
# * %clang-lib compiles plain C code (that possibly includes libacc2omp-provided
#   headers) into a shared object.  For example, this makes sense for OpenACC
#   profiling libraries and alternate libacc2omp backends.
#
# Common behavior:
# * All substitutions include options for required OpenACC/OpenMP includes and
#   libraries.
# * No substitution includes source file arguments, the "-o" option, pipelines,
#   or file redirects.
# * All substitutions include "-verify" options:
#   * The "expected" prefix is always enabled.  The "host" prefix is enabled
#     only for the "host" sub test suite.  For other sub test suites, prefixes
#     are enabled based on the omp_device_t spellings of the selected offload
#     device types (e.g., "x86_64", "nvptx64") if the substitution compiles for
#     offloading.
#   * To expect no diagnostics for all cases:
#
#       // expected-no-diagnostics
#
#   * To expect diagnostics for nvptx64 but not for any other case:
#
#       // expected-error 0 {{}}
#       // nvptx64-warning@*:* 1+ {{Linking two modules of different data layouts}}
#
#   * FIXME: It would be nice if "-verify" supported an
#     "expected-no-other-diagnostics", which would have the same semantics as
#     "expected-no-diagnostics" except it would be ignored when any other
#     directive is specified.  That is, it would behave like
#     "expected-error 0 {{}}", but its intention would be clearer.

# Select device types for offload compilation based on sub test suite.
if config.libacc2omp_current_target == 'host':
    selected_tgts = ['host']
    fopenmp_targets = ''
elif config.libacc2omp_current_target == 'multitarget':
    selected_tgts = config.libacc2omp_system_targets
    fopenmp_targets = ' -fopenmp-targets=' + str.join(',', selected_tgts)
else:
    selected_tgts = [config.libacc2omp_current_target]
    fopenmp_targets = ' -fopenmp-targets=' + str.join(',', selected_tgts)

# The OpenMP version required by the OpenACC implementation.
fopenmp_version = ' -fopenmp-version=51'

# Diagnostic options.
verify = ' -Xclang -verify=expected'
verify_tgts = verify
for tgt in selected_tgts:
    verify_tgts += "," + tgtToOMP(tgt)

# Header and library options.
incs = ' -isystem {acc} -isystem {omp}'.format(
  acc=config.acc2omp_header_directory, omp=config.omp_header_directory)
acc_libs = ' -lacc2omp'
bc_libs = ''
if any(tgtToOMP(tgt) == "amdgcn" for tgt in selected_tgts):
    bc_libs += " --libomptarget-amdgcn-bc-path=" + config.libomptarget_dir
if any(tgtToOMP(tgt) == "nvptx64" for tgt in selected_tgts):
    bc_libs += " --libomptarget-nvptx-bc-path=" + config.libomptarget_dir

# Start with plain clang.
clang = config.test_c_compiler

# Generally, we need to be aware of dead code in our tests, especially because
# unused static functions might be test cases that are accidentally not invoked.
clang += " -Werror=unused-function"

# Make sure the build's libraries are used not the system's.
clang += " -L " + config.libacc2omp_dir
clang += " -L " + config.libomp_dir
clang += " -L " + config.libomptarget_dir

# %clang-*
config.substitutions.append(('%clang-lib',
  clang + incs + verify + ' -shared -fpic'))
config.substitutions.append(('%clang-acc-prt-omp',
  clang + ' -fopenacc-print=omp' + incs + verify +
  ' -Wno-openacc-omp-map-ompx-hold'))
config.substitutions.append(('%clang-acc-fsyntax-only',
  clang + ' -fopenacc -fsyntax-only' + incs + verify))
# Add %clang-acc after %clang-acc-* or the latter will never substitute.
config.substitutions.append(('%clang-acc',
  clang + ' -fopenacc' + fopenmp_targets + bc_libs + incs + verify_tgts))
config.substitutions.append(('%clang-omp',
  clang + ' -fopenmp' + fopenmp_version + bc_libs + fopenmp_targets + incs + \
  verify_tgts + acc_libs))

#-------------------------------------------------------------------------------
# %if-<COND>(<TRUE>, <FALSE>)
#
# <COND> values:
# * "host" indicates compilation only for host (i.e., "host" sub test suite).
# * "multi" indicates compilation for multiple offload device types (i.e.,
#   "multitarget" sub test suite).
# * "tgt-stdio" indicates that all device types selected for compilation support
#   stdio (e.g., "printf") in target regions.
#
# Common behavior:
# * Expands to <TRUE> if the condition indicated by <COND> is true, and expands
#   to <FALSE> otherwise.
# * <TRUE> and <FALSE> cannot include any character in the set "(),".  As a
#   result, these substitutions cannot appear in each other's arguments.
# * Either <TRUE> or <FALSE> can be the empty string.
# * Any whitespace characters immediately following the "," are discarded.

config.substitutions.append(('%if-host\(([^,()]*), *([^,()]*)\)',
  '\\1' if config.libacc2omp_current_target == 'host' else '\\2'))
config.substitutions.append(('%if-multi\(([^,()]*), *([^,()]*)\)',
  '\\1' if len(selected_tgts) > 1 else '\\2'))
config.substitutions.append(('%if-tgt-stdio\(([^,()]*), *([^,()]*)\)',
  '\\1' if any(tgtSupportsStdio(tgt) for tgt in selected_tgts) else '\\2'))

#-------------------------------------------------------------------------------
# %dev-type-<N>-<ATTR>
#
# <N> = "0" or "1" to specify the first or last offload device type selected for
# compilation.  These are always the same except in the case of the multitarget
# test suite.  Both indicate host in the case of the "host" sub test suite, and
# they do not indicate host in any other sub test suite.
#
# <ATTR> specifies an attribute of the specified device type:
# * "acc", "ACC", "omp", or "OMP" specifies the acc_device_t or omp_device_t
#   spelling, either lowercase or uppercase, for the specified device type.  For
#   example, for an NVIDIA GPU, the expansion is "nvidia", "NVIDIA", "nvptx64",
#   or "NVPTX64", respectively.  For the "host" sub test suite, "acc" and "omp"
#   specify expansion to "host", and "ACC" and "OMP" specify expansion to
#   "HOST".
# * "num-devs" specifies the number of devices of that type.  For the "host" sub
#   test suite, it's always 1.
# * "last-dev" specifies the value of "num-devs" - 1.
# * "copy" specifies whether LLVM's implementation performs intra-device data
#   copies directly (expands to "direct") or via the host (expands to
#   "by-host").  In the case of the "host" sub test suite, it always expands to
#   "direct".

tgt0 = selected_tgts[0]
tgt1 = selected_tgts[-1]
if config.libacc2omp_current_target == 'host':
    tgt0_ndevs = 1
    tgt1_ndevs = 1
else:
    tgt0_ndevs = getattr(config, "clang_acc_test_exe_" + tgtToOMP(tgt0))
    tgt1_ndevs = getattr(config, "clang_acc_test_exe_" + tgtToOMP(tgt1))
config.substitutions.append(('%dev-type-0-acc', tgtToACC(tgt0)))
config.substitutions.append(('%dev-type-0-omp', tgtToOMP(tgt0)))
config.substitutions.append(('%dev-type-0-ACC', str.upper(tgtToACC(tgt0))))
config.substitutions.append(('%dev-type-0-OMP', str.upper(tgtToOMP(tgt0))))
config.substitutions.append(('%dev-type-1-acc', tgtToACC(tgt1)))
config.substitutions.append(('%dev-type-1-omp', tgtToOMP(tgt1)))
config.substitutions.append(('%dev-type-1-ACC', str.upper(tgtToACC(tgt1))))
config.substitutions.append(('%dev-type-1-OMP', str.upper(tgtToOMP(tgt1))))
config.substitutions.append(('%dev-type-0-num-devs', tgt0_ndevs))
config.substitutions.append(('%dev-type-1-num-devs', tgt1_ndevs))
config.substitutions.append(('%dev-type-0-last-dev', tgt0_ndevs - 1))
config.substitutions.append(('%dev-type-1-last-dev', tgt1_ndevs - 1))
config.substitutions.append(('%dev-type-0-copy', tgtCopy(tgt0)))
config.substitutions.append(('%dev-type-1-copy', tgtCopy(tgt1)))

#-------------------------------------------------------------------------------
# Other device data.
#
# %<OMP-DEV>-num-devs
# * <OMP-DEV> is the omp_device_t spelling of an offload device type.  For
#   example, "x86_64" or "nvptx64" but not "host".
# * Expands to the number of devices of the specified offload device type if it
#   is selected for compilation.  Expands to 0 otherwise.
#
# %bad-dev-type-acc
# * Expands to the acc_device_t spelling of one arbitrarily selected offload
#   device type that is not selected for compilation.  For example, "x86_64" or
#   "nvidia".
#
# %not-host-num-devs
# * Expands to the number of devices that are of offload device types selected
#   for compilation.  In other words, it's the number of devices that are
#   indicated by "acc_device_not_host".

found_bad = False
for tgt in config.libacc2omp_all_targets:
    tgt_omp = tgtToOMP(tgt)
    if tgt == "host":
        config.substitutions.append(("%" + tgt_omp + "-num-devs", "1"))
    elif tgt in selected_tgts:
        config.substitutions.append(("%" + tgt_omp + "-num-devs",
          getattr(config, "clang_acc_test_exe_" + tgt_omp)))
    else:
        config.substitutions.append(("%" + tgt_omp + "-num-devs", "0"))
        if tgtToOMP(tgt) in ["x86_64", "ppc64le", "nvptx64", "amdgcn"]:
            found_bad = True
            config.substitutions.append(("%bad-dev-type-acc",
                                         tgtToACC(tgt)))
assert found_bad and "didn't expect system with all possible target types"

not_host_num_devs = 0
if config.libacc2omp_current_target != 'host':
    for tgt in selected_tgts:
        not_host_num_devs += getattr(config, "clang_acc_test_exe_" +
                                             tgtToOMP(tgt))
config.substitutions.append(('%not-host-num-devs', not_host_num_devs))

#-------------------------------------------------------------------------------
# Miscellaneous substitutions.

# %not is the usual "not" used throughout LLVM's test suites.
config.substitutions.append(("%not", config.test_not))

# FileCheck defaults to complaining about unused prefixes, but we have many.
config.substitutions.append(("FileCheck", config.test_filecheck +
                                          " --allow-unused-prefixes"))

# %preload-t.so preloads %t.so, which the test should have already compiled.
config.substitutions.append(("%preload-t.so", "env LD_PRELOAD=%t.so"))

# The OpenACC version reported throughout Clang's implementation.
config.substitutions.append(('%acc-version', '202011'))
